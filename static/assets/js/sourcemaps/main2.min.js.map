{"version":3,"sources":["main.js","fluidvids.js","search-lunr-ajax-call.js","toggle-navigation.js","toggle-search.js","lunr.js","_globals.js","console-message-to-fellow-developers.js","polyfills.js"],"names":["vidCheck","document","getElementsByTagName","length","fluidvids","init","selector","players","video","matches","src","RegExp","join","test","getRatio","height","width","parseInt","fluid","elem","data","getAttribute","wrap","createElement","parentNode","insertBefore","className","setAttribute","style","paddingTop","appendChild","addStyles","div","innerHTML","css","head","childNodes","render","nodes","querySelectorAll","i","obj","key","lunrSearch","event","query","getElementById","value","searchResults","keyCode","window","index","search","displayResults","results","inputVal","forEach","result","item","searchData","ref","appendString","url","title","description","navToggle","$","toggleClass","toggleSearch","evt","preventDefault","searchForm","searchInput","classList","toggle","contains","focus","lunr","config","idx","Index","pipeline","add","trimmer","stopWordFilter","stemmer","call","version","utils","warn","global","message","console","this","asString","toString","EventEmitter","events","prototype","addListener","args","Array","slice","arguments","fn","pop","names","TypeError","name","hasHandler","push","removeListener","fnIndex","indexOf","splice","emit","apply","undefined","tokenizer","isArray","map","t","toLowerCase","trim","split","seperator","load","label","registeredFunctions","Error","default","registerFunction","Pipeline","_stack","warnIfFunctionNotRegistered","isRegistered","serialised","fnName","fns","after","existingFn","newFn","pos","before","remove","run","tokens","out","tokenLength","stackLength","token","j","reset","toJSON","Vector","_magnitude","list","Node","val","next","insert","prev","magnitude","node","sumOfSquares","Math","sqrt","dot","otherVector","otherNode","dotProduct","similarity","SortedSet","elements","serialisedData","set","element","locationFor","toArray","ctx","start","end","sectionLength","pivot","floor","pivotElem","intersect","otherSet","intersectSet","a_len","b_len","a","b","clone","union","longSet","shortSet","unionSet","shortSetElements","_fields","_ref","documentStore","Store","tokenStore","TokenStore","corpusTokens","eventEmitter","tokenizerFn","_idfCache","on","bind","off","fields","field","fieldName","opts","boost","refName","doc","emitEvent","docTokens","allDocumentTokens","docRef","fieldTokens","tf","fieldLength","tokenCount","k","has","get","update","idf","term","cacheKey","Object","hasOwnProperty","documentFrequency","count","log","queryTokens","queryVector","documentSets","fieldBoosts","reduce","memo","f","hasSomeToken","some","self","expand","similarityBoost","diff","max","matchingDocuments","refs","keys","refsLen","documentSet","score","documentVector","sort","documentRef","documentTokens","documentTokensLength","use","plugin","unshift","store","id","step2list","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3list","icate","ative","alize","iciti","ical","ful","ness","c","v","C","V","mgr0","meq1","mgr1","s_v","re_mgr0","re_mgr1","re_meq1","re_s_v","re_1a","re2_1a","re_1b","re2_1b","re_1b_2","re2_1b_2","re3_1b_2","re4_1b_2","re_1c","re_2","re_3","re_4","re2_4","re_5","re_5_1","re3_5","porterStemmer","w","stem","suffix","firstch","re","re2","re3","re4","substr","toUpperCase","replace","fp","exec","generateStopWordFilter","stopWords","words","stopWord","root","docs","charAt","rest","getNode","concat","isMac","navigator","userAgent","onload","String","startsWith","searchString","position","includes","endsWith","subjectString","isFinite","lastIndex","m","Element","q","p","o","n","code","DOMException","g","d","s","r","_updateClassName","e","defineProperty","l","enumerable","configurable","h","number","__defineGetter__","addEventListener","indexLocation","searchReq","XMLHttpRequest","open","status","JSON","parse","response","onerror","send","querySelector"],"mappings":"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AQ,EAAAzB,EACAwB,EAAA/T,KAAA2T,IAAAK,EAAAhU,KAAA2T,KACAI,EAAAjB,EACAa,EAAAA,EAAAU,QAAAN,EAAA,KAKA,KAAAD,IACAH,EAAAG,EAAAjN,cAAA8M,EAAAQ,OAAA,IAGAR,EAGA,OAAAD,MAGA1P,EAAAuD,SAAAD,iBAAAtD,EAAAQ,QAAA,WAmBAR,EAAAwQ,uBAAA,SAAAC,GACA,GAAAC,GAAAD,EAAAnG,OAAA,SAAAC,EAAAoG,GAEA,MADApG,GAAAoG,GAAAA,EACApG,MAGA,OAAA,UAAA9F,GACA,GAAAA,GAAAiM,EAAAjM,KAAAA,EAAA,MAAAA,KAgBAzE,EAAAO,eAAAP,EAAAwQ,wBACA,IACA,OACA,QACA,SACA,QACA,MACA,SACA,OACA,KACA,QACA,KACA,MACA,MACA,MACA,KACA,KACA,KACA,UACA,OACA,MACA,KACA,MACA,SACA,QACA,OACA,MACA,KACA,OACA,SACA,OACA,OACA,QACA,MACA,OACA,MACA,MACA,MACA,MACA,OACA,KACA,MACA,OACA,MACA,MACA,MACA,UACA,IACA,KACA,KACA,OACA,KACA,KACA,MACA,OACA,QACA,MACA,OACA,SACA,MACA,KACA,QACA,OACA,OACA,KACA,UACA,KACA,MACA,MACA,KACA,MACA,QACA,KACA,OACA,KACA,QACA,MACA,MACA,SACA,OACA,MACA,OACA,MACA,SACA,QACA,KACA,OACA,OACA,OACA,MACA,QACA,OACA,OACA,QACA,QACA,OACA,OACA,MACA,KACA,MACA,OACA,KACA,QACA,MACA,KACA,OACA,OACA,OACA,QACA,QACA,QACA,MACA,OACA,MACA,OACA,OACA,QACA,MACA,MACA,SAGAxQ,EAAAuD,SAAAD,iBAAAtD,EAAAO,eAAA,kBAoBAP,EAAAM,QAAA,SAAAmE,GACA,MAAAA,GAAA4L,QAAA,OAAA,IAAAA,QAAA,OAAA,KAGArQ,EAAAuD,SAAAD,iBAAAtD,EAAAM,QAAA,WAaAN,EAAA+H,WAAA,WACA/G,KAAA4P,MAAAC,SACA7P,KAAA1F,OAAA,GAUA0E,EAAA+H,WA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","file":"main2.min.js","sourcesContent":["\"use strict\";\n\n(function () {\n    var lunr = function lunr(config) {\n        var idx = new lunr.Index();\n\n        idx.pipeline.add(lunr.trimmer, lunr.stopWordFilter, lunr.stemmer);\n\n        if (config) config.call(idx, idx);\n\n        return idx;\n    };\n\n    lunr.version = \"0.7.1\";\n    lunr.utils = {};\n    lunr.utils.warn = function (global) {\n        return function (message) {\n            if (global.console && console.warn) {\n                console.warn(message);\n            }\n        };\n    }(this);\n    lunr.utils.asString = function (obj) {\n        if (obj === void 0 || obj === null) {\n            return \"\";\n        } else {\n            return obj.toString();\n        }\n    };\n    lunr.EventEmitter = function () {\n        this.events = {};\n    };\n\n    /**\n     * Binds a handler function to a specific event(s).\n     *\n     * Can bind a single function to many different events in one call.\n     *\n     * @param {String} [eventName] The name(s) of events to bind this function to.\n     * @param {Function} fn The function to call when an event is fired.\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.addListener = function () {\n        var args = Array.prototype.slice.call(arguments),\n            fn = args.pop(),\n            names = args;\n\n        if (typeof fn !== \"function\") throw new TypeError(\"last argument must be a function\");\n\n        names.forEach(function (name) {\n            if (!this.hasHandler(name)) this.events[name] = [];\n            this.events[name].push(fn);\n        }, this);\n    };\n\n    /**\n     * Removes a handler function from a specific event.\n     *\n     * @param {String} eventName The name of the event to remove this function from.\n     * @param {Function} fn The function to remove from an event.\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.removeListener = function (name, fn) {\n        if (!this.hasHandler(name)) return;\n\n        var fnIndex = this.events[name].indexOf(fn);\n        this.events[name].splice(fnIndex, 1);\n\n        if (!this.events[name].length) delete this.events[name];\n    };\n\n    /**\n     * Calls all functions bound to the given event.\n     *\n     * Additional data can be passed to the event handler as arguments to `emit`\n     * after the event name.\n     *\n     * @param {String} eventName The name of the event to emit.\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.emit = function (name) {\n        if (!this.hasHandler(name)) return;\n\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        this.events[name].forEach(function (fn) {\n            fn.apply(undefined, args);\n        });\n    };\n\n    /**\n     * Checks whether a handler has ever been stored against an event.\n     *\n     * @param {String} eventName The name of the event to check.\n     * @private\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.hasHandler = function (name) {\n        return name in this.events;\n    };\n\n    /*!\n     * lunr.tokenizer\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * A function for splitting a string into tokens ready to be inserted into\n     * the search index. Uses `lunr.tokenizer.seperator` to split strings, change\n     * the value of this property to change how strings are split into tokens.\n     *\n     * @module\n     * @param {String} obj The string to convert into tokens\n     * @see lunr.tokenizer.seperator\n     * @returns {Array}\n     */\n    lunr.tokenizer = function (obj) {\n        if (!arguments.length || obj == null || obj == undefined) return [];\n        if (Array.isArray(obj)) return obj.map(function (t) {\n            return lunr.utils.asString(t).toLowerCase();\n        });\n\n        return obj.toString().trim().toLowerCase().split(lunr.tokenizer.seperator);\n    };\n\n    /**\n     * The sperator used to split a string into tokens. Override this property to change the behaviour of\n     * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.\n     *\n     * @static\n     * @see lunr.tokenizer\n     */\n    lunr.tokenizer.seperator = /[\\s\\-]+/;\n\n    /**\n     * Loads a previously serialised tokenizer.\n     *\n     * A tokenizer function to be loaded must already be registered with lunr.tokenizer.\n     * If the serialised tokenizer has not been registered then an error will be thrown.\n     *\n     * @param {String} label The label of the serialised tokenizer.\n     * @returns {Function}\n     * @memberOf tokenizer\n     */\n    lunr.tokenizer.load = function (label) {\n        var fn = this.registeredFunctions[label];\n\n        if (!fn) {\n            throw new Error('Cannot load un-registered function: ' + label);\n        }\n\n        return fn;\n    };\n\n    lunr.tokenizer.label = 'default';\n\n    lunr.tokenizer.registeredFunctions = {\n        'default': lunr.tokenizer\n    };\n\n    /**\n     * Register a tokenizer function.\n     *\n     * Functions that are used as tokenizers should be registered if they are to be used with a serialised index.\n     *\n     * Registering a function does not add it to an index, functions must still be associated with a specific index for them to be used when indexing and searching documents.\n     *\n     * @param {Function} fn The function to register.\n     * @param {String} label The label to register this function with\n     * @memberOf tokenizer\n     */\n    lunr.tokenizer.registerFunction = function (fn, label) {\n        if (label in this.registeredFunctions) {\n            lunr.utils.warn('Overwriting existing tokenizer: ' + label);\n        }\n\n        fn.label = label;\n        this.registeredFunctions[label] = fn;\n    };\n    /*!\n     * lunr.Pipeline\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.Pipelines maintain an ordered list of functions to be applied to all\n     * tokens in documents entering the search index and queries being ran against\n     * the index.\n     *\n     * An instance of lunr.Index created with the lunr shortcut will contain a\n     * pipeline with a stop word filter and an English language stemmer. Extra\n     * functions can be added before or after either of these functions or these\n     * default functions can be removed.\n     *\n     * When run the pipeline will call each function in turn, passing a token, the\n     * index of that token in the original list of all tokens and finally a list of\n     * all the original tokens.\n     *\n     * The output of functions in the pipeline will be passed to the next function\n     * in the pipeline. To exclude a token from entering the index the function\n     * should return undefined, the rest of the pipeline will not be called with\n     * this token.\n     *\n     * For serialisation of pipelines to work, all functions used in an instance of\n     * a pipeline should be registered with lunr.Pipeline. Registered functions can\n     * then be loaded. If trying to load a serialised pipeline that uses functions\n     * that are not registered an error will be thrown.\n     *\n     * If not planning on serialising the pipeline then registering pipeline functions\n     * is not necessary.\n     *\n     * @constructor\n     */\n    lunr.Pipeline = function () {\n        this._stack = [];\n    };\n\n    lunr.Pipeline.registeredFunctions = {};\n\n    /**\n     * Register a function with the pipeline.\n     *\n     * Functions that are used in the pipeline should be registered if the pipeline\n     * needs to be serialised, or a serialised pipeline needs to be loaded.\n     *\n     * Registering a function does not add it to a pipeline, functions must still be\n     * added to instances of the pipeline for them to be used when running a pipeline.\n     *\n     * @param {Function} fn The function to check for.\n     * @param {String} label The label to register this function with\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.registerFunction = function (fn, label) {\n        if (label in this.registeredFunctions) {\n            lunr.utils.warn('Overwriting existing registered function: ' + label);\n        }\n\n        fn.label = label;\n        lunr.Pipeline.registeredFunctions[fn.label] = fn;\n    };\n\n    /**\n     * Warns if the function is not registered as a Pipeline function.\n     *\n     * @param {Function} fn The function to check for.\n     * @private\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {\n        var isRegistered = fn.label && fn.label in this.registeredFunctions;\n\n        if (!isRegistered) {\n            lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\\n', fn);\n        }\n    };\n\n    /**\n     * Loads a previously serialised pipeline.\n     *\n     * All functions to be loaded must already be registered with lunr.Pipeline.\n     * If any function from the serialised data has not been registered then an\n     * error will be thrown.\n     *\n     * @param {Object} serialised The serialised pipeline to load.\n     * @returns {lunr.Pipeline}\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.load = function (serialised) {\n        var pipeline = new lunr.Pipeline();\n\n        serialised.forEach(function (fnName) {\n            var fn = lunr.Pipeline.registeredFunctions[fnName];\n\n            if (fn) {\n                pipeline.add(fn);\n            } else {\n                throw new Error('Cannot load un-registered function: ' + fnName);\n            }\n        });\n\n        return pipeline;\n    };\n\n    /**\n     * Adds new functions to the end of the pipeline.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @param {Function} functions Any number of functions to add to the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.add = function () {\n        var fns = Array.prototype.slice.call(arguments);\n\n        fns.forEach(function (fn) {\n            lunr.Pipeline.warnIfFunctionNotRegistered(fn);\n            this._stack.push(fn);\n        }, this);\n    };\n\n    /**\n     * Adds a single function after a function that already exists in the\n     * pipeline.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @param {Function} existingFn A function that already exists in the pipeline.\n     * @param {Function} newFn The new function to add to the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.after = function (existingFn, newFn) {\n        lunr.Pipeline.warnIfFunctionNotRegistered(newFn);\n\n        var pos = this._stack.indexOf(existingFn);\n        if (pos == -1) {\n            throw new Error('Cannot find existingFn');\n        }\n\n        pos = pos + 1;\n        this._stack.splice(pos, 0, newFn);\n    };\n\n    /**\n     * Adds a single function before a function that already exists in the\n     * pipeline.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @param {Function} existingFn A function that already exists in the pipeline.\n     * @param {Function} newFn The new function to add to the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.before = function (existingFn, newFn) {\n        lunr.Pipeline.warnIfFunctionNotRegistered(newFn);\n\n        var pos = this._stack.indexOf(existingFn);\n        if (pos == -1) {\n            throw new Error('Cannot find existingFn');\n        }\n\n        this._stack.splice(pos, 0, newFn);\n    };\n\n    /**\n     * Removes a function from the pipeline.\n     *\n     * @param {Function} fn The function to remove from the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.remove = function (fn) {\n        var pos = this._stack.indexOf(fn);\n        if (pos == -1) {\n            return;\n        }\n\n        this._stack.splice(pos, 1);\n    };\n\n    /**\n     * Runs the current list of functions that make up the pipeline against the\n     * passed tokens.\n     *\n     * @param {Array} tokens The tokens to run through the pipeline.\n     * @returns {Array}\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.run = function (tokens) {\n        var out = [],\n            tokenLength = tokens.length,\n            stackLength = this._stack.length;\n\n        for (var i = 0; i < tokenLength; i++) {\n            var token = tokens[i];\n\n            for (var j = 0; j < stackLength; j++) {\n                token = this._stack[j](token, i, tokens);\n                if (token === void 0 || token === '') break;\n            };\n\n            if (token !== void 0 && token !== '') out.push(token);\n        };\n\n        return out;\n    };\n\n    /**\n     * Resets the pipeline by removing any existing processors.\n     *\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.reset = function () {\n        this._stack = [];\n    };\n\n    /**\n     * Returns a representation of the pipeline ready for serialisation.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @returns {Array}\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.toJSON = function () {\n        return this._stack.map(function (fn) {\n            lunr.Pipeline.warnIfFunctionNotRegistered(fn);\n\n            return fn.label;\n        });\n    };\n    /*!\n     * lunr.Vector\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.Vectors implement vector related operations for\n     * a series of elements.\n     *\n     * @constructor\n     */\n    lunr.Vector = function () {\n        this._magnitude = null;\n        this.list = undefined;\n        this.length = 0;\n    };\n\n    /**\n     * lunr.Vector.Node is a simple struct for each node\n     * in a lunr.Vector.\n     *\n     * @private\n     * @param {Number} The index of the node in the vector.\n     * @param {Object} The data at this node in the vector.\n     * @param {lunr.Vector.Node} The node directly after this node in the vector.\n     * @constructor\n     * @memberOf Vector\n     */\n    lunr.Vector.Node = function (idx, val, next) {\n        this.idx = idx;\n        this.val = val;\n        this.next = next;\n    };\n\n    /**\n     * Inserts a new value at a position in a vector.\n     *\n     * @param {Number} The index at which to insert a value.\n     * @param {Object} The object to insert in the vector.\n     * @memberOf Vector.\n     */\n    lunr.Vector.prototype.insert = function (idx, val) {\n        this._magnitude = undefined;\n        var list = this.list;\n\n        if (!list) {\n            this.list = new lunr.Vector.Node(idx, val, list);\n            return this.length++;\n        }\n\n        if (idx < list.idx) {\n            this.list = new lunr.Vector.Node(idx, val, list);\n            return this.length++;\n        }\n\n        var prev = list,\n            next = list.next;\n\n        while (next != undefined) {\n            if (idx < next.idx) {\n                prev.next = new lunr.Vector.Node(idx, val, next);\n                return this.length++;\n            }\n\n            prev = next, next = next.next;\n        }\n\n        prev.next = new lunr.Vector.Node(idx, val, next);\n        return this.length++;\n    };\n\n    /**\n     * Calculates the magnitude of this vector.\n     *\n     * @returns {Number}\n     * @memberOf Vector\n     */\n    lunr.Vector.prototype.magnitude = function () {\n        if (this._magnitude) return this._magnitude;\n        var node = this.list,\n            sumOfSquares = 0,\n            val;\n\n        while (node) {\n            val = node.val;\n            sumOfSquares += val * val;\n            node = node.next;\n        }\n\n        return this._magnitude = Math.sqrt(sumOfSquares);\n    };\n\n    /**\n     * Calculates the dot product of this vector and another vector.\n     *\n     * @param {lunr.Vector} otherVector The vector to compute the dot product with.\n     * @returns {Number}\n     * @memberOf Vector\n     */\n    lunr.Vector.prototype.dot = function (otherVector) {\n        var node = this.list,\n            otherNode = otherVector.list,\n            dotProduct = 0;\n\n        while (node && otherNode) {\n            if (node.idx < otherNode.idx) {\n                node = node.next;\n            } else if (node.idx > otherNode.idx) {\n                otherNode = otherNode.next;\n            } else {\n                dotProduct += node.val * otherNode.val;\n                node = node.next;\n                otherNode = otherNode.next;\n            }\n        }\n\n        return dotProduct;\n    };\n\n    /**\n     * Calculates the cosine similarity between this vector and another\n     * vector.\n     *\n     * @param {lunr.Vector} otherVector The other vector to calculate the\n     * similarity with.\n     * @returns {Number}\n     * @memberOf Vector\n     */\n    lunr.Vector.prototype.similarity = function (otherVector) {\n        return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude());\n    };\n    /*!\n     * lunr.SortedSet\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.SortedSets are used to maintain an array of uniq values in a sorted\n     * order.\n     *\n     * @constructor\n     */\n    lunr.SortedSet = function () {\n        this.length = 0;\n        this.elements = [];\n    };\n\n    /**\n     * Loads a previously serialised sorted set.\n     *\n     * @param {Array} serialisedData The serialised set to load.\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.load = function (serialisedData) {\n        var set = new this();\n\n        set.elements = serialisedData;\n        set.length = serialisedData.length;\n\n        return set;\n    };\n\n    /**\n     * Inserts new items into the set in the correct position to maintain the\n     * order.\n     *\n     * @param {Object} The objects to add to this set.\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.add = function () {\n        var i, element;\n\n        for (i = 0; i < arguments.length; i++) {\n            element = arguments[i];\n            if (~this.indexOf(element)) continue;\n            this.elements.splice(this.locationFor(element), 0, element);\n        }\n\n        this.length = this.elements.length;\n    };\n\n    /**\n     * Converts this sorted set into an array.\n     *\n     * @returns {Array}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.toArray = function () {\n        return this.elements.slice();\n    };\n\n    /**\n     * Creates a new array with the results of calling a provided function on every\n     * element in this sorted set.\n     *\n     * Delegates to Array.prototype.map and has the same signature.\n     *\n     * @param {Function} fn The function that is called on each element of the\n     * set.\n     * @param {Object} ctx An optional object that can be used as the context\n     * for the function fn.\n     * @returns {Array}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.map = function (fn, ctx) {\n        return this.elements.map(fn, ctx);\n    };\n\n    /**\n     * Executes a provided function once per sorted set element.\n     *\n     * Delegates to Array.prototype.forEach and has the same signature.\n     *\n     * @param {Function} fn The function that is called on each element of the\n     * set.\n     * @param {Object} ctx An optional object that can be used as the context\n     * @memberOf SortedSet\n     * for the function fn.\n     */\n    lunr.SortedSet.prototype.forEach = function (fn, ctx) {\n        return this.elements.forEach(fn, ctx);\n    };\n\n    /**\n     * Returns the index at which a given element can be found in the\n     * sorted set, or -1 if it is not present.\n     *\n     * @param {Object} elem The object to locate in the sorted set.\n     * @returns {Number}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.indexOf = function (elem) {\n        var start = 0,\n            end = this.elements.length,\n            sectionLength = end - start,\n            pivot = start + Math.floor(sectionLength / 2),\n            pivotElem = this.elements[pivot];\n\n        while (sectionLength > 1) {\n            if (pivotElem === elem) return pivot;\n\n            if (pivotElem < elem) start = pivot;\n            if (pivotElem > elem) end = pivot;\n\n            sectionLength = end - start;\n            pivot = start + Math.floor(sectionLength / 2);\n            pivotElem = this.elements[pivot];\n        }\n\n        if (pivotElem === elem) return pivot;\n\n        return -1;\n    };\n\n    /**\n     * Returns the position within the sorted set that an element should be\n     * inserted at to maintain the current order of the set.\n     *\n     * This function assumes that the element to search for does not already exist\n     * in the sorted set.\n     *\n     * @param {Object} elem The elem to find the position for in the set\n     * @returns {Number}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.locationFor = function (elem) {\n        var start = 0,\n            end = this.elements.length,\n            sectionLength = end - start,\n            pivot = start + Math.floor(sectionLength / 2),\n            pivotElem = this.elements[pivot];\n\n        while (sectionLength > 1) {\n            if (pivotElem < elem) start = pivot;\n            if (pivotElem > elem) end = pivot;\n\n            sectionLength = end - start;\n            pivot = start + Math.floor(sectionLength / 2);\n            pivotElem = this.elements[pivot];\n        }\n\n        if (pivotElem > elem) return pivot;\n        if (pivotElem < elem) return pivot + 1;\n    };\n\n    /**\n     * Creates a new lunr.SortedSet that contains the elements in the intersection\n     * of this set and the passed set.\n     *\n     * @param {lunr.SortedSet} otherSet The set to intersect with this set.\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.intersect = function (otherSet) {\n        var intersectSet = new lunr.SortedSet(),\n            i = 0,\n            j = 0,\n            a_len = this.length,\n            b_len = otherSet.length,\n            a = this.elements,\n            b = otherSet.elements;\n\n        while (true) {\n            if (i > a_len - 1 || j > b_len - 1) break;\n\n            if (a[i] === b[j]) {\n                intersectSet.add(a[i]);\n                i++, j++;\n                continue;\n            }\n\n            if (a[i] < b[j]) {\n                i++;\n                continue;\n            }\n\n            if (a[i] > b[j]) {\n                j++;\n                continue;\n            }\n        };\n\n        return intersectSet;\n    };\n\n    /**\n     * Makes a copy of this set\n     *\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.clone = function () {\n        var clone = new lunr.SortedSet();\n\n        clone.elements = this.toArray();\n        clone.length = clone.elements.length;\n\n        return clone;\n    };\n\n    /**\n     * Creates a new lunr.SortedSet that contains the elements in the union\n     * of this set and the passed set.\n     *\n     * @param {lunr.SortedSet} otherSet The set to union with this set.\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.union = function (otherSet) {\n        var longSet, shortSet, unionSet;\n\n        if (this.length >= otherSet.length) {\n            longSet = this, shortSet = otherSet;\n        } else {\n            longSet = otherSet, shortSet = this;\n        }\n\n        unionSet = longSet.clone();\n\n        for (var i = 0, shortSetElements = shortSet.toArray(); i < shortSetElements.length; i++) {\n            unionSet.add(shortSetElements[i]);\n        }\n\n        return unionSet;\n    };\n\n    /**\n     * Returns a representation of the sorted set ready for serialisation.\n     *\n     * @returns {Array}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.toJSON = function () {\n        return this.toArray();\n    };\n    /*!\n     * lunr.Index\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.Index is object that manages a search index.  It contains the indexes\n     * and stores all the tokens and document lookups.  It also provides the main\n     * user facing API for the library.\n     *\n     * @constructor\n     */\n    lunr.Index = function () {\n        this._fields = [];\n        this._ref = 'id';\n        this.pipeline = new lunr.Pipeline();\n        this.documentStore = new lunr.Store();\n        this.tokenStore = new lunr.TokenStore();\n        this.corpusTokens = new lunr.SortedSet();\n        this.eventEmitter = new lunr.EventEmitter();\n        this.tokenizerFn = lunr.tokenizer;\n\n        this._idfCache = {};\n\n        this.on('add', 'remove', 'update', function () {\n            this._idfCache = {};\n        }.bind(this));\n    };\n\n    /**\n     * Bind a handler to events being emitted by the index.\n     *\n     * The handler can be bound to many events at the same time.\n     *\n     * @param {String} [eventName] The name(s) of events to bind the function to.\n     * @param {Function} fn The serialised set to load.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.on = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return this.eventEmitter.addListener.apply(this.eventEmitter, args);\n    };\n\n    /**\n     * Removes a handler from an event being emitted by the index.\n     *\n     * @param {String} eventName The name of events to remove the function from.\n     * @param {Function} fn The serialised set to load.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.off = function (name, fn) {\n        return this.eventEmitter.removeListener(name, fn);\n    };\n\n    /**\n     * Loads a previously serialised index.\n     *\n     * Issues a warning if the index being imported was serialised\n     * by a different version of lunr.\n     *\n     * @param {Object} serialisedData The serialised set to load.\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.load = function (serialisedData) {\n        if (serialisedData.version !== lunr.version) {\n            lunr.utils.warn('version mismatch: current ' + lunr.version + ' importing ' + serialisedData.version);\n        }\n\n        var idx = new this();\n\n        idx._fields = serialisedData.fields;\n        idx._ref = serialisedData.ref;\n\n        idx.tokenizer = lunr.tokenizer.load(serialisedData.tokenizer);\n        idx.documentStore = lunr.Store.load(serialisedData.documentStore);\n        idx.tokenStore = lunr.TokenStore.load(serialisedData.tokenStore);\n        idx.corpusTokens = lunr.SortedSet.load(serialisedData.corpusTokens);\n        idx.pipeline = lunr.Pipeline.load(serialisedData.pipeline);\n\n        return idx;\n    };\n\n    /**\n     * Adds a field to the list of fields that will be searchable within documents\n     * in the index.\n     *\n     * An optional boost param can be passed to affect how much tokens in this field\n     * rank in search results, by default the boost value is 1.\n     *\n     * Fields should be added before any documents are added to the index, fields\n     * that are added after documents are added to the index will only apply to new\n     * documents added to the index.\n     *\n     * @param {String} fieldName The name of the field within the document that\n     * should be indexed\n     * @param {Number} boost An optional boost that can be applied to terms in this\n     * field.\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.field = function (fieldName, opts) {\n        var opts = opts || {},\n            field = { name: fieldName, boost: opts.boost || 1 };\n\n        this._fields.push(field);\n        return this;\n    };\n\n    /**\n     * Sets the property used to uniquely identify documents added to the index,\n     * by default this property is 'id'.\n     *\n     * This should only be changed before adding documents to the index, changing\n     * the ref property without resetting the index can lead to unexpected results.\n     *\n     * The value of ref can be of any type but it _must_ be stably comparable and\n     * orderable.\n     *\n     * @param {String} refName The property to use to uniquely identify the\n     * documents in the index.\n     * @param {Boolean} emitEvent Whether to emit add events, defaults to true\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.ref = function (refName) {\n        this._ref = refName;\n        return this;\n    };\n\n    /**\n     * Sets the tokenizer used for this index.\n     *\n     * By default the index will use the default tokenizer, lunr.tokenizer. The tokenizer\n     * should only be changed before adding documents to the index. Changing the tokenizer\n     * without re-building the index can lead to unexpected results.\n     *\n     * @param {Function} fn The function to use as a tokenizer.\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.tokenizer = function (fn) {\n        var isRegistered = fn.label && fn.label in lunr.tokenizer.registeredFunctions;\n\n        if (!isRegistered) {\n            lunr.utils.warn('Function is not a registered tokenizer. This may cause problems when serialising the index');\n        }\n\n        this.tokenizerFn = fn;\n        return this;\n    };\n\n    /**\n     * Add a document to the index.\n     *\n     * This is the way new documents enter the index, this function will run the\n     * fields from the document through the index's pipeline and then add it to\n     * the index, it will then show up in search results.\n     *\n     * An 'add' event is emitted with the document that has been added and the index\n     * the document has been added to. This event can be silenced by passing false\n     * as the second argument to add.\n     *\n     * @param {Object} doc The document to add to the index.\n     * @param {Boolean} emitEvent Whether or not to emit events, default true.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.add = function (doc, emitEvent) {\n        var docTokens = {},\n            allDocumentTokens = new lunr.SortedSet(),\n            docRef = doc[this._ref],\n            emitEvent = emitEvent === undefined ? true : emitEvent;\n\n        this._fields.forEach(function (field) {\n            var fieldTokens = this.pipeline.run(this.tokenizerFn(doc[field.name]));\n\n            docTokens[field.name] = fieldTokens;\n\n            for (var i = 0; i < fieldTokens.length; i++) {\n                var token = fieldTokens[i];\n                allDocumentTokens.add(token);\n                this.corpusTokens.add(token);\n            }\n        }, this);\n\n        this.documentStore.set(docRef, allDocumentTokens);\n\n        for (var i = 0; i < allDocumentTokens.length; i++) {\n            var token = allDocumentTokens.elements[i];\n            var tf = 0;\n\n            for (var j = 0; j < this._fields.length; j++) {\n                var field = this._fields[j];\n                var fieldTokens = docTokens[field.name];\n                var fieldLength = fieldTokens.length;\n\n                if (!fieldLength) continue;\n\n                var tokenCount = 0;\n                for (var k = 0; k < fieldLength; k++) {\n                    if (fieldTokens[k] === token) {\n                        tokenCount++;\n                    }\n                }\n\n                tf += tokenCount / fieldLength * field.boost;\n            }\n\n            this.tokenStore.add(token, { ref: docRef, tf: tf });\n        };\n\n        if (emitEvent) this.eventEmitter.emit('add', doc, this);\n    };\n\n    /**\n     * Removes a document from the index.\n     *\n     * To make sure documents no longer show up in search results they can be\n     * removed from the index using this method.\n     *\n     * The document passed only needs to have the same ref property value as the\n     * document that was added to the index, they could be completely different\n     * objects.\n     *\n     * A 'remove' event is emitted with the document that has been removed and the index\n     * the document has been removed from. This event can be silenced by passing false\n     * as the second argument to remove.\n     *\n     * @param {Object} doc The document to remove from the index.\n     * @param {Boolean} emitEvent Whether to emit remove events, defaults to true\n     * @memberOf Index\n     */\n    lunr.Index.prototype.remove = function (doc, emitEvent) {\n        var docRef = doc[this._ref],\n            emitEvent = emitEvent === undefined ? true : emitEvent;\n\n        if (!this.documentStore.has(docRef)) return;\n\n        var docTokens = this.documentStore.get(docRef);\n\n        this.documentStore.remove(docRef);\n\n        docTokens.forEach(function (token) {\n            this.tokenStore.remove(token, docRef);\n        }, this);\n\n        if (emitEvent) this.eventEmitter.emit('remove', doc, this);\n    };\n\n    /**\n     * Updates a document in the index.\n     *\n     * When a document contained within the index gets updated, fields changed,\n     * added or removed, to make sure it correctly matched against search queries,\n     * it should be updated in the index.\n     *\n     * This method is just a wrapper around `remove` and `add`\n     *\n     * An 'update' event is emitted with the document that has been updated and the index.\n     * This event can be silenced by passing false as the second argument to update. Only\n     * an update event will be fired, the 'add' and 'remove' events of the underlying calls\n     * are silenced.\n     *\n     * @param {Object} doc The document to update in the index.\n     * @param {Boolean} emitEvent Whether to emit update events, defaults to true\n     * @see Index.prototype.remove\n     * @see Index.prototype.add\n     * @memberOf Index\n     */\n    lunr.Index.prototype.update = function (doc, emitEvent) {\n        var emitEvent = emitEvent === undefined ? true : emitEvent;\n\n        this.remove(doc, false);\n        this.add(doc, false);\n\n        if (emitEvent) this.eventEmitter.emit('update', doc, this);\n    };\n\n    /**\n     * Calculates the inverse document frequency for a token within the index.\n     *\n     * @param {String} token The token to calculate the idf of.\n     * @see Index.prototype.idf\n     * @private\n     * @memberOf Index\n     */\n    lunr.Index.prototype.idf = function (term) {\n        var cacheKey = \"@\" + term;\n        if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey];\n\n        var documentFrequency = this.tokenStore.count(term),\n            idf = 1;\n\n        if (documentFrequency > 0) {\n            idf = 1 + Math.log(this.documentStore.length / documentFrequency);\n        }\n\n        return this._idfCache[cacheKey] = idf;\n    };\n\n    /**\n     * Searches the index using the passed query.\n     *\n     * Queries should be a string, multiple words are allowed and will lead to an\n     * AND based query, e.g. `idx.search('foo bar')` will run a search for\n     * documents containing both 'foo' and 'bar'.\n     *\n     * All query tokens are passed through the same pipeline that document tokens\n     * are passed through, so any language processing involved will be run on every\n     * query term.\n     *\n     * Each query term is expanded, so that the term 'he' might be expanded to\n     * 'hello' and 'help' if those terms were already included in the index.\n     *\n     * Matching documents are returned as an array of objects, each object contains\n     * the matching document ref, as set for this index, and the similarity score\n     * for this document against the query.\n     *\n     * @param {String} query The query to search the index with.\n     * @returns {Object}\n     * @see Index.prototype.idf\n     * @see Index.prototype.documentVector\n     * @memberOf Index\n     */\n    lunr.Index.prototype.search = function (query) {\n        var queryTokens = this.pipeline.run(this.tokenizerFn(query)),\n            queryVector = new lunr.Vector(),\n            documentSets = [],\n            fieldBoosts = this._fields.reduce(function (memo, f) {\n            return memo + f.boost;\n        }, 0);\n\n        var hasSomeToken = queryTokens.some(function (token) {\n            return this.tokenStore.has(token);\n        }, this);\n\n        if (!hasSomeToken) return [];\n\n        queryTokens.forEach(function (token, i, tokens) {\n            var tf = 1 / tokens.length * this._fields.length * fieldBoosts,\n                self = this;\n\n            var set = this.tokenStore.expand(token).reduce(function (memo, key) {\n                var pos = self.corpusTokens.indexOf(key),\n                    idf = self.idf(key),\n                    similarityBoost = 1,\n                    set = new lunr.SortedSet();\n\n                // if the expanded key is not an exact match to the token then\n                // penalise the score for this key by how different the key is\n                // to the token.\n                if (key !== token) {\n                    var diff = Math.max(3, key.length - token.length);\n                    similarityBoost = 1 / Math.log(diff);\n                }\n\n                // calculate the query tf-idf score for this token\n                // applying an similarityBoost to ensure exact matches\n                // these rank higher than expanded terms\n                if (pos > -1) queryVector.insert(pos, tf * idf * similarityBoost);\n\n                // add all the documents that have this key into a set\n                // ensuring that the type of key is preserved\n                var matchingDocuments = self.tokenStore.get(key),\n                    refs = Object.keys(matchingDocuments),\n                    refsLen = refs.length;\n\n                for (var i = 0; i < refsLen; i++) {\n                    set.add(matchingDocuments[refs[i]].ref);\n                }\n\n                return memo.union(set);\n            }, new lunr.SortedSet());\n\n            documentSets.push(set);\n        }, this);\n\n        var documentSet = documentSets.reduce(function (memo, set) {\n            return memo.intersect(set);\n        });\n\n        return documentSet.map(function (ref) {\n            return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) };\n        }, this).sort(function (a, b) {\n            return b.score - a.score;\n        });\n    };\n\n    /**\n     * Generates a vector containing all the tokens in the document matching the\n     * passed documentRef.\n     *\n     * The vector contains the tf-idf score for each token contained in the\n     * document with the passed documentRef.  The vector will contain an element\n     * for every token in the indexes corpus, if the document does not contain that\n     * token the element will be 0.\n     *\n     * @param {Object} documentRef The ref to find the document with.\n     * @returns {lunr.Vector}\n     * @private\n     * @memberOf Index\n     */\n    lunr.Index.prototype.documentVector = function (documentRef) {\n        var documentTokens = this.documentStore.get(documentRef),\n            documentTokensLength = documentTokens.length,\n            documentVector = new lunr.Vector();\n\n        for (var i = 0; i < documentTokensLength; i++) {\n            var token = documentTokens.elements[i],\n                tf = this.tokenStore.get(token)[documentRef].tf,\n                idf = this.idf(token);\n\n            documentVector.insert(this.corpusTokens.indexOf(token), tf * idf);\n        };\n\n        return documentVector;\n    };\n\n    /**\n     * Returns a representation of the index ready for serialisation.\n     *\n     * @returns {Object}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.toJSON = function () {\n        return {\n            version: lunr.version,\n            fields: this._fields,\n            ref: this._ref,\n            tokenizer: this.tokenizerFn.label,\n            documentStore: this.documentStore.toJSON(),\n            tokenStore: this.tokenStore.toJSON(),\n            corpusTokens: this.corpusTokens.toJSON(),\n            pipeline: this.pipeline.toJSON()\n        };\n    };\n\n    /**\n     * Applies a plugin to the current index.\n     *\n     * A plugin is a function that is called with the index as its context.\n     * Plugins can be used to customise or extend the behaviour the index\n     * in some way. A plugin is just a function, that encapsulated the custom\n     * behaviour that should be applied to the index.\n     *\n     * The plugin function will be called with the index as its argument, additional\n     * arguments can also be passed when calling use. The function will be called\n     * with the index as its context.\n     *\n     * Example:\n     *\n     *     var myPlugin = function (idx, arg1, arg2) {\n     *       // `this` is the index to be extended\n     *       // apply any extensions etc here.\n     *     }\n     *\n     *     var idx = lunr(function () {\n     *       this.use(myPlugin, 'arg1', 'arg2')\n     *     })\n     *\n     * @param {Function} plugin The plugin to apply.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.use = function (plugin) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        args.unshift(this);\n        plugin.apply(this, args);\n    };\n    /*!\n     * lunr.Store\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.Store is a simple key-value store used for storing sets of tokens for\n     * documents stored in index.\n     *\n     * @constructor\n     * @module\n     */\n    lunr.Store = function () {\n        this.store = {};\n        this.length = 0;\n    };\n\n    /**\n     * Loads a previously serialised store\n     *\n     * @param {Object} serialisedData The serialised store to load.\n     * @returns {lunr.Store}\n     * @memberOf Store\n     */\n    lunr.Store.load = function (serialisedData) {\n        var store = new this();\n\n        store.length = serialisedData.length;\n        store.store = Object.keys(serialisedData.store).reduce(function (memo, key) {\n            memo[key] = lunr.SortedSet.load(serialisedData.store[key]);\n            return memo;\n        }, {});\n\n        return store;\n    };\n\n    /**\n     * Stores the given tokens in the store against the given id.\n     *\n     * @param {Object} id The key used to store the tokens against.\n     * @param {Object} tokens The tokens to store against the key.\n     * @memberOf Store\n     */\n    lunr.Store.prototype.set = function (id, tokens) {\n        if (!this.has(id)) this.length++;\n        this.store[id] = tokens;\n    };\n\n    /**\n     * Retrieves the tokens from the store for a given key.\n     *\n     * @param {Object} id The key to lookup and retrieve from the store.\n     * @returns {Object}\n     * @memberOf Store\n     */\n    lunr.Store.prototype.get = function (id) {\n        return this.store[id];\n    };\n\n    /**\n     * Checks whether the store contains a key.\n     *\n     * @param {Object} id The id to look up in the store.\n     * @returns {Boolean}\n     * @memberOf Store\n     */\n    lunr.Store.prototype.has = function (id) {\n        return id in this.store;\n    };\n\n    /**\n     * Removes the value for a key in the store.\n     *\n     * @param {Object} id The id to remove from the store.\n     * @memberOf Store\n     */\n    lunr.Store.prototype.remove = function (id) {\n        if (!this.has(id)) return;\n\n        delete this.store[id];\n        this.length--;\n    };\n\n    /**\n     * Returns a representation of the store ready for serialisation.\n     *\n     * @returns {Object}\n     * @memberOf Store\n     */\n    lunr.Store.prototype.toJSON = function () {\n        return {\n            store: this.store,\n            length: this.length\n        };\n    };\n\n    /*!\n     * lunr.stemmer\n     * Copyright (C) 2016 Oliver Nightingale\n     * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n     */\n\n    /**\n     * lunr.stemmer is an english language stemmer, this is a JavaScript\n     * implementation of the PorterStemmer taken from http://tartarus.org/~martin\n     *\n     * @module\n     * @param {String} str The string to stem\n     * @returns {String}\n     * @see lunr.Pipeline\n     */\n    lunr.stemmer = function () {\n        var step2list = {\n            \"ational\": \"ate\",\n            \"tional\": \"tion\",\n            \"enci\": \"ence\",\n            \"anci\": \"ance\",\n            \"izer\": \"ize\",\n            \"bli\": \"ble\",\n            \"alli\": \"al\",\n            \"entli\": \"ent\",\n            \"eli\": \"e\",\n            \"ousli\": \"ous\",\n            \"ization\": \"ize\",\n            \"ation\": \"ate\",\n            \"ator\": \"ate\",\n            \"alism\": \"al\",\n            \"iveness\": \"ive\",\n            \"fulness\": \"ful\",\n            \"ousness\": \"ous\",\n            \"aliti\": \"al\",\n            \"iviti\": \"ive\",\n            \"biliti\": \"ble\",\n            \"logi\": \"log\"\n        },\n            step3list = {\n            \"icate\": \"ic\",\n            \"ative\": \"\",\n            \"alize\": \"al\",\n            \"iciti\": \"ic\",\n            \"ical\": \"ic\",\n            \"ful\": \"\",\n            \"ness\": \"\"\n        },\n            c = \"[^aeiou]\",\n            // consonant\n        v = \"[aeiouy]\",\n            // vowel\n        C = c + \"[^aeiouy]*\",\n            // consonant sequence\n        V = v + \"[aeiou]*\",\n            // vowel sequence\n\n        mgr0 = \"^(\" + C + \")?\" + V + C,\n            // [C]VC... is m>0\n        meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\",\n            // [C]VC[V] is m=1\n        mgr1 = \"^(\" + C + \")?\" + V + C + V + C,\n            // [C]VCVC... is m>1\n        s_v = \"^(\" + C + \")?\" + v; // vowel in stem\n\n        var re_mgr0 = new RegExp(mgr0);\n        var re_mgr1 = new RegExp(mgr1);\n        var re_meq1 = new RegExp(meq1);\n        var re_s_v = new RegExp(s_v);\n\n        var re_1a = /^(.+?)(ss|i)es$/;\n        var re2_1a = /^(.+?)([^s])s$/;\n        var re_1b = /^(.+?)eed$/;\n        var re2_1b = /^(.+?)(ed|ing)$/;\n        var re_1b_2 = /.$/;\n        var re2_1b_2 = /(at|bl|iz)$/;\n        var re3_1b_2 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n        var re4_1b_2 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n        var re_1c = /^(.+?[^aeiou])y$/;\n        var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n\n        var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n\n        var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n        var re2_4 = /^(.+?)(s|t)(ion)$/;\n\n        var re_5 = /^(.+?)e$/;\n        var re_5_1 = /ll$/;\n        var re3_5 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n        var porterStemmer = function porterStemmer(w) {\n            var stem, suffix, firstch, re, re2, re3, re4;\n\n            if (w.length < 3) {\n                return w;\n            }\n\n            firstch = w.substr(0, 1);\n            if (firstch == \"y\") {\n                w = firstch.toUpperCase() + w.substr(1);\n            }\n\n            // Step 1a\n            re = re_1a;\n            re2 = re2_1a;\n\n            if (re.test(w)) {\n                w = w.replace(re, \"$1$2\");\n            } else if (re2.test(w)) {\n                w = w.replace(re2, \"$1$2\");\n            }\n\n            // Step 1b\n            re = re_1b;\n            re2 = re2_1b;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                re = re_mgr0;\n                if (re.test(fp[1])) {\n                    re = re_1b_2;\n                    w = w.replace(re, \"\");\n                }\n            } else if (re2.test(w)) {\n                var fp = re2.exec(w);\n                stem = fp[1];\n                re2 = re_s_v;\n                if (re2.test(stem)) {\n                    w = stem;\n                    re2 = re2_1b_2;\n                    re3 = re3_1b_2;\n                    re4 = re4_1b_2;\n                    if (re2.test(w)) {\n                        w = w + \"e\";\n                    } else if (re3.test(w)) {\n                        re = re_1b_2;\n                        w = w.replace(re, \"\");\n                    } else if (re4.test(w)) {\n                        w = w + \"e\";\n                    }\n                }\n            }\n\n            // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)\n            re = re_1c;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                w = stem + \"i\";\n            }\n\n            // Step 2\n            re = re_2;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                suffix = fp[2];\n                re = re_mgr0;\n                if (re.test(stem)) {\n                    w = stem + step2list[suffix];\n                }\n            }\n\n            // Step 3\n            re = re_3;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                suffix = fp[2];\n                re = re_mgr0;\n                if (re.test(stem)) {\n                    w = stem + step3list[suffix];\n                }\n            }\n\n            // Step 4\n            re = re_4;\n            re2 = re2_4;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                re = re_mgr1;\n                if (re.test(stem)) {\n                    w = stem;\n                }\n            } else if (re2.test(w)) {\n                var fp = re2.exec(w);\n                stem = fp[1] + fp[2];\n                re2 = re_mgr1;\n                if (re2.test(stem)) {\n                    w = stem;\n                }\n            }\n\n            // Step 5\n            re = re_5;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                re = re_mgr1;\n                re2 = re_meq1;\n                re3 = re3_5;\n                if (re.test(stem) || re2.test(stem) && !re3.test(stem)) {\n                    w = stem;\n                }\n            }\n\n            re = re_5_1;\n            re2 = re_mgr1;\n            if (re.test(w) && re2.test(w)) {\n                re = re_1b_2;\n                w = w.replace(re, \"\");\n            }\n\n            // and turn initial Y back to y\n\n            if (firstch == \"y\") {\n                w = firstch.toLowerCase() + w.substr(1);\n            }\n\n            return w;\n        };\n\n        return porterStemmer;\n    }();\n\n    lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer');\n    /*!\n     * lunr.stopWordFilter\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.generateStopWordFilter builds a stopWordFilter function from the provided\n     * list of stop words.\n     *\n     * The built in lunr.stopWordFilter is built using this generator and can be used\n     * to generate custom stopWordFilters for applications or non English languages.\n     *\n     * @module\n     * @param {Array} token The token to pass through the filter\n     * @returns {Function}\n     * @see lunr.Pipeline\n     * @see lunr.stopWordFilter\n     */\n    lunr.generateStopWordFilter = function (stopWords) {\n        var words = stopWords.reduce(function (memo, stopWord) {\n            memo[stopWord] = stopWord;\n            return memo;\n        }, {});\n\n        return function (token) {\n            if (token && words[token] !== token) return token;\n        };\n    };\n\n    /**\n     * lunr.stopWordFilter is an English language stop word list filter, any words\n     * contained in the list will not be passed through the filter.\n     *\n     * This is intended to be used in the Pipeline. If the token does not pass the\n     * filter then undefined will be returned.\n     *\n     * @module\n     * @param {String} token The token to pass through the filter\n     * @returns {String}\n     * @see lunr.Pipeline\n     */\n    lunr.stopWordFilter = lunr.generateStopWordFilter(['a', 'able', 'about', 'across', 'after', 'all', 'almost', 'also', 'am', 'among', 'an', 'and', 'any', 'are', 'as', 'at', 'be', 'because', 'been', 'but', 'by', 'can', 'cannot', 'could', 'dear', 'did', 'do', 'does', 'either', 'else', 'ever', 'every', 'for', 'from', 'get', 'got', 'had', 'has', 'have', 'he', 'her', 'hers', 'him', 'his', 'how', 'however', 'i', 'if', 'in', 'into', 'is', 'it', 'its', 'just', 'least', 'let', 'like', 'likely', 'may', 'me', 'might', 'most', 'must', 'my', 'neither', 'no', 'nor', 'not', 'of', 'off', 'often', 'on', 'only', 'or', 'other', 'our', 'own', 'rather', 'said', 'say', 'says', 'she', 'should', 'since', 'so', 'some', 'than', 'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'tis', 'to', 'too', 'twas', 'us', 'wants', 'was', 'we', 'were', 'what', 'when', 'where', 'which', 'while', 'who', 'whom', 'why', 'will', 'with', 'would', 'yet', 'you', 'your']);\n\n    lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter');\n    /*!\n     * lunr.trimmer\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * lunr.trimmer is a pipeline function for trimming non word\n     * characters from the begining and end of tokens before they\n     * enter the index.\n     *\n     * This implementation may not work correctly for non latin\n     * characters and should either be removed or adapted for use\n     * with languages with non-latin characters.\n     *\n     * @module\n     * @param {String} token The token to pass through the filter\n     * @returns {String}\n     * @see lunr.Pipeline\n     */\n    lunr.trimmer = function (token) {\n        return token.replace(/^\\W+/, '').replace(/\\W+$/, '');\n    };\n\n    lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer');\n    /*!\n     * lunr.stemmer\n     * Copyright (C) 2016 Oliver Nightingale\n     * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n     */\n\n    /**\n     * lunr.TokenStore is used for efficient storing and lookup of the reverse\n     * index of token to document ref.\n     *\n     * @constructor\n     */\n    lunr.TokenStore = function () {\n        this.root = { docs: {} };\n        this.length = 0;\n    };\n\n    /**\n     * Loads a previously serialised token store\n     *\n     * @param {Object} serialisedData The serialised token store to load.\n     * @returns {lunr.TokenStore}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.load = function (serialisedData) {\n        var store = new this();\n\n        store.root = serialisedData.root;\n        store.length = serialisedData.length;\n\n        return store;\n    };\n\n    /**\n     * Adds a new token doc pair to the store.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to store the doc under\n     * @param {Object} doc The doc to store against the token\n     * @param {Object} root An optional node at which to start looking for the\n     * correct place to enter the doc, by default the root of this lunr.TokenStore\n     * is used.\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.add = function (token, doc, root) {\n        var root = root || this.root,\n            key = token.charAt(0),\n            rest = token.slice(1);\n\n        if (!(key in root)) root[key] = { docs: {} };\n\n        if (rest.length === 0) {\n            root[key].docs[doc.ref] = doc;\n            this.length += 1;\n            return;\n        } else {\n            return this.add(rest, doc, root[key]);\n        }\n    };\n\n    /**\n     * Checks whether this key is contained within this lunr.TokenStore.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to check for\n     * @param {Object} root An optional node at which to start\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.has = function (token) {\n        if (!token) return false;\n\n        var node = this.root;\n\n        for (var i = 0; i < token.length; i++) {\n            if (!node[token.charAt(i)]) return false;\n\n            node = node[token.charAt(i)];\n        }\n\n        return true;\n    };\n\n    /**\n     * Retrieve a node from the token store for a given token.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to get the node for.\n     * @param {Object} root An optional node at which to start.\n     * @returns {Object}\n     * @see TokenStore.prototype.get\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.getNode = function (token) {\n        if (!token) return {};\n\n        var node = this.root;\n\n        for (var i = 0; i < token.length; i++) {\n            if (!node[token.charAt(i)]) return {};\n\n            node = node[token.charAt(i)];\n        }\n\n        return node;\n    };\n\n    /**\n     * Retrieve the documents for a node for the given token.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to get the documents for.\n     * @param {Object} root An optional node at which to start.\n     * @returns {Object}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.get = function (token, root) {\n        return this.getNode(token, root).docs || {};\n    };\n\n    lunr.TokenStore.prototype.count = function (token, root) {\n        return Object.keys(this.get(token, root)).length;\n    };\n\n    /**\n     * Remove the document identified by ref from the token in the store.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to get the documents for.\n     * @param {String} ref The ref of the document to remove from this token.\n     * @param {Object} root An optional node at which to start.\n     * @returns {Object}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.remove = function (token, ref) {\n        if (!token) return;\n        var node = this.root;\n\n        for (var i = 0; i < token.length; i++) {\n            if (!(token.charAt(i) in node)) return;\n            node = node[token.charAt(i)];\n        }\n\n        delete node.docs[ref];\n    };\n\n    /**\n     * Find all the possible suffixes of the passed token using tokens\n     * currently in the store.\n     *\n     * @param {String} token The token to expand.\n     * @returns {Array}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.expand = function (token, memo) {\n        var root = this.getNode(token),\n            docs = root.docs || {},\n            memo = memo || [];\n\n        if (Object.keys(docs).length) memo.push(token);\n\n        Object.keys(root).forEach(function (key) {\n            if (key === 'docs') return;\n\n            memo.concat(this.expand(token + key, memo));\n        }, this);\n\n        return memo;\n    };\n\n    /**\n     * Returns a representation of the token store ready for serialisation.\n     *\n     * @returns {Object}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.toJSON = function () {\n        return {\n            root: this.root,\n            length: this.length\n        };\n    };\n    return lunr;\n})();\n\nvar isMac = navigator.userAgent.indexOf('Mac OS X') != -1 ? true : false;\nconsole.log(\"%cHey there, fellow developer. Find me on GitHub at https://github.com/rdwatters - Cheers.\", \"font-size: 20px; color: #01589B; font-family:'proximanova';\");\nwindow.onload = vidCheck;\n\nfunction vidCheck() {\n    if (document.getElementsByTagName('iframe').length > 0) {\n        fluidvids.init({\n            selector: ['iframe', 'object'], // runs querySelectorAll()\n            players: ['www.youtube.com', 'player.vimeo.com'] // players to support\n        });\n    }\n}\n\nfunction video() {\n\n    var fluidvids = {\n        selector: ['iframe', 'object'],\n        players: ['www.youtube.com', 'player.vimeo.com']\n    };\n\n    var css = ['.fluidvids {', 'width: 100%; max-width: 100%; position: relative;', '}', '.fluidvids-item {', 'position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;', '}'].join('');\n\n    var head = document.head || document.getElementsByTagName('head')[0];\n\n    function matches(src) {\n        return new RegExp('^(https?:)?\\/\\/(?:' + fluidvids.players.join('|') + ').*$', 'i').test(src);\n    }\n\n    function getRatio(height, width) {\n        return parseInt(height, 10) / parseInt(width, 10) * 100 + '%';\n    }\n\n    function fluid(elem) {\n        if (!matches(elem.src) && !matches(elem.data) || !!elem.getAttribute('data-fluidvids')) return;\n        var wrap = document.createElement('div');\n        elem.parentNode.insertBefore(wrap, elem);\n        elem.className += (elem.className ? ' ' : '') + 'fluidvids-item';\n        elem.setAttribute('data-fluidvids', 'loaded');\n        wrap.className += 'fluidvids';\n        wrap.style.paddingTop = getRatio(elem.height, elem.width);\n        wrap.appendChild(elem);\n    }\n\n    function addStyles() {\n        var div = document.createElement('div');\n        div.innerHTML = '<p>x</p><style>' + css + '</style>';\n        head.appendChild(div.childNodes[1]);\n    }\n\n    fluidvids.render = function () {\n        var nodes = document.querySelectorAll(fluidvids.selector.join());\n        var i = nodes.length;\n        while (i--) {\n            fluid(nodes[i]);\n        }\n    };\n\n    fluidvids.init = function (obj) {\n        for (var key in obj) {\n            fluidvids[key] = obj[key];\n        }\n        fluidvids.render();\n        addStyles();\n    };\n\n    return fluidvids.init({\n        selector: ['iframe', 'object'], // runs querySelectorAll()\n        players: ['www.youtube.com', 'player.vimeo.com'] // players to support\n    });\n};\n\n//es2015 extra string methods *not* transpiled with Babel\nif (!String.prototype.startsWith) {\n    String.prototype.startsWith = function (searchString, position) {\n        position = position || 0;\n        return this.indexOf(searchString, position) === position;\n    };\n}\nif (!String.prototype.includes) {\n    String.prototype.includes = function () {\n        'use strict';\n\n        return String.prototype.indexOf.apply(this, arguments) !== -1;\n    };\n}\nif (!String.prototype.endsWith) {\n    String.prototype.endsWith = function (searchString, position) {\n        var subjectString = this.toString();\n        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n            position = subjectString.length;\n        }\n        position -= searchString.length;\n        var lastIndex = subjectString.indexOf(searchString, position);\n        return lastIndex !== -1 && lastIndex === position;\n    };\n}\n//http://purl.eligrey.com/github/classList.js/blob/master/classList.js\n\nif (\"document\" in self && !(\"classList\" in document.createElement(\"_\"))) {\n    (function (j) {\n        \"use strict\";\n\n        if (!(\"Element\" in j)) {\n            return;\n        }\n        var a = \"classList\",\n            f = \"prototype\",\n            m = j.Element[f],\n            b = Object,\n            k = String[f].trim || function () {\n            return this.replace(/^\\s+|\\s+$/g, \"\");\n        },\n            c = Array[f].indexOf || function (q) {\n            var p = 0,\n                o = this.length;\n            for (; p < o; p++) {\n                if (p in this && this[p] === q) {\n                    return p;\n                }\n            }\n            return -1;\n        },\n            n = function n(o, p) {\n            this.name = o;\n            this.code = DOMException[o];\n            this.message = p;\n        },\n            g = function g(p, o) {\n            if (o === \"\") {\n                throw new n(\"SYNTAX_ERR\", \"An invalid or illegal string was specified\");\n            }\n            if (/\\s/.test(o)) {\n                throw new n(\"INVALID_CHARACTER_ERR\", \"String contains an invalid character\");\n            }\n            return c.call(p, o);\n        },\n            d = function d(s) {\n            var r = k.call(s.getAttribute(\"class\") || \"\"),\n                q = r ? r.split(/\\s+/) : [],\n                p = 0,\n                o = q.length;\n            for (; p < o; p++) {\n                this.push(q[p]);\n            }\n            this._updateClassName = function () {\n                s.setAttribute(\"class\", this.toString());\n            };\n        },\n            e = d[f] = [],\n            i = function i() {\n            return new d(this);\n        };\n        n[f] = Error[f];\n        e.item = function (o) {\n            return this[o] || null;\n        };\n        e.contains = function (o) {\n            o += \"\";\n            return g(this, o) !== -1;\n        };\n        e.add = function () {\n            var s = arguments,\n                r = 0,\n                p = s.length,\n                q,\n                o = false;\n            do {\n                q = s[r] + \"\";\n                if (g(this, q) === -1) {\n                    this.push(q);\n                    o = true;\n                }\n            } while (++r < p);\n            if (o) {\n                this._updateClassName();\n            }\n        };\n        e.remove = function () {\n            var t = arguments,\n                s = 0,\n                p = t.length,\n                r,\n                o = false;\n            do {\n                r = t[s] + \"\";\n                var q = g(this, r);\n                if (q !== -1) {\n                    this.splice(q, 1);\n                    o = true;\n                }\n            } while (++s < p);\n            if (o) {\n                this._updateClassName();\n            }\n        };\n        e.toggle = function (p, q) {\n            p += \"\";\n            var o = this.contains(p),\n                r = o ? q !== true && \"remove\" : q !== false && \"add\";\n            if (r) {\n                this[r](p);\n            }\n            return !o;\n        };\n        e.toString = function () {\n            return this.join(\" \");\n        };\n        if (b.defineProperty) {\n            var l = {\n                get: i,\n                enumerable: true,\n                configurable: true\n            };\n            try {\n                b.defineProperty(m, a, l);\n            } catch (h) {\n                if (h.number === -2146823252) {\n                    l.enumerable = false;\n                    b.defineProperty(m, a, l);\n                }\n            }\n        } else {\n            if (b[f].__defineGetter__) {\n                m.__defineGetter__(a, i);\n            }\n        }\n    })(self);\n};\nvar searchData;\nvar searchInput = document.getElementById('search-input');\nsearchInput.addEventListener('keyup', lunrSearch, true);\nwindow.index = lunr(function () {\n    this.field('id');\n    this.field('url');\n    this.field('title', { boost: 100 });\n    this.field('subtitle');\n    this.field('description');\n    this.field('tags', { boost: 30 });\n    this.field('content', { boost: 10 });\n});\nvar indexLocation = \"/assets/site-index.json\";\nvar searchReq = new XMLHttpRequest();\nsearchReq.open('GET', indexLocation, true);\nsearchReq.onload = function () {\n    if (this.status >= 200 && this.status < 400) {\n        searchData = JSON.parse(this.response);\n        searchData.forEach(function (obj, index) {\n            obj['id'] = index;\n            window.index.add(obj);\n        });\n    } else {\n        console.log(\"Failed status for site-index.js.\");\n    }\n};\nsearchReq.onerror = function () {\n    console.log(\"Error when attempting to load site-index.json.\");\n};\nsearchReq.send();\n\nfunction lunrSearch(event) {\n    var query = document.getElementById(\"search-input\").value;\n    var searchResults = document.getElementById(\"search-results\");\n    if (query.length < 3) {\n        searchResults.innerHTML = '';\n    }\n    if (event.keyCode !== 9 && query.length > 2) {\n        var matches = window.index.search(query);\n        displayResults(matches);\n    }\n}\n\nfunction displayResults(results) {\n    var searchResults = document.getElementById('search-results');\n    var inputVal = document.getElementById('search-input').value;\n    if (results.length) {\n        searchResults.innerHTML = '';\n        results.forEach(function (result) {\n            var item = window.searchData[result.ref];\n            var appendString = '<li class=\\\"search-result\\\"><a href=\\\"' + item.url + '\\\"><h5>' + item.title + '</h5>' + '<p>' + item.description + '</p></li>';\n            searchResults.innerHTML += appendString;\n        });\n    } else {\n        searchResults.innerHTML = '<li class=\\\"search-result none\\\">No results found for <span class=\\\"input-value\\\">' + inputVal + '</span>. Please check spelling and spacing.</li>';\n    }\n}\n\ndocument.querySelector('.sidebar-toggle-wrapper').addEventListener('click', navToggle, false);\n\nfunction navToggle() {\n    $('.sidebar-toggle-wrapper,.site-navigation').toggleClass('open');\n}\ndocument.getElementById('toggle-search').addEventListener('click', toggleSearch, false);\ndocument.getElementById('close-search').addEventListener('click', toggleSearch, false);\n\nfunction toggleSearch(evt) {\n    evt.preventDefault();\n    var searchForm = document.getElementById('site-search');\n    var searchInput = document.getElementById('search-input');\n    searchForm.classList.toggle('open');\n    if (!searchForm.classList.contains('open')) {\n        searchInput.value = '';\n    } else {\n        document.getElementById('search-input').focus();\n    }\n}","window.onload = vidCheck;\n\nfunction vidCheck() {\n    if (document.getElementsByTagName('iframe').length > 0) {\n        fluidvids.init({\n            selector: ['iframe', 'object'], // runs querySelectorAll()\n            players: ['www.youtube.com', 'player.vimeo.com'] // players to support\n        });\n    }\n}\n\nfunction video() {\n\n    var fluidvids = {\n        selector: ['iframe', 'object'],\n        players: ['www.youtube.com', 'player.vimeo.com']\n    };\n\n    var css = [\n        '.fluidvids {',\n        'width: 100%; max-width: 100%; position: relative;',\n        '}',\n        '.fluidvids-item {',\n        'position: absolute; top: 0px; left: 0px; width: 100%; height: 100%;',\n        '}'\n    ].join('');\n\n    var head = document.head || document.getElementsByTagName('head')[0];\n\n    function matches(src) {\n        return new RegExp('^(https?:)?\\/\\/(?:' + fluidvids.players.join('|') + ').*$', 'i').test(src);\n    }\n\n    function getRatio(height, width) {\n        return ((parseInt(height, 10) / parseInt(width, 10)) * 100) + '%';\n    }\n\n    function fluid(elem) {\n        if (!matches(elem.src) && !matches(elem.data) || !!elem.getAttribute('data-fluidvids')) return;\n        var wrap = document.createElement('div');\n        elem.parentNode.insertBefore(wrap, elem);\n        elem.className += (elem.className ? ' ' : '') + 'fluidvids-item';\n        elem.setAttribute('data-fluidvids', 'loaded');\n        wrap.className += 'fluidvids';\n        wrap.style.paddingTop = getRatio(elem.height, elem.width);\n        wrap.appendChild(elem);\n    }\n\n    function addStyles() {\n        var div = document.createElement('div');\n        div.innerHTML = '<p>x</p><style>' + css + '</style>';\n        head.appendChild(div.childNodes[1]);\n    }\n\n    fluidvids.render = function() {\n        var nodes = document.querySelectorAll(fluidvids.selector.join());\n        var i = nodes.length;\n        while (i--) {\n            fluid(nodes[i]);\n        }\n    };\n\n    fluidvids.init = function(obj) {\n        for (var key in obj) {\n            fluidvids[key] = obj[key];\n        }\n        fluidvids.render();\n        addStyles();\n    };\n\n    return fluidvids.init({\n        selector: ['iframe', 'object'], // runs querySelectorAll()\n        players: ['www.youtube.com', 'player.vimeo.com'] // players to support\n    });\n\n};\n","var searchData;\nvar searchInput = document.getElementById('search-input');\nsearchInput.addEventListener('keyup', lunrSearch, true);\nwindow.index = lunr(function() {\n    this.field('id');\n    this.field('url');\n    this.field('title', { boost: 100 });\n    this.field('subtitle');\n    this.field('description');\n    this.field('tags', { boost: 30 });\n    this.field('content', { boost: 10 });\n});\nvar indexLocation = \"/assets/site-index.json\";\nvar searchReq = new XMLHttpRequest();\nsearchReq.open('GET', indexLocation, true);\nsearchReq.onload = function() {\n    if (this.status >= 200 && this.status < 400) {\n        searchData = JSON.parse(this.response);\n        searchData.forEach(function(obj, index) {\n            obj['id'] = index;\n            window.index.add(obj);\n        });\n    } else {\n        console.log(\"Failed status for site-index.js.\");\n    }\n};\nsearchReq.onerror = function() {\n    console.log(\"Error when attempting to load site-index.json.\");\n}\nsearchReq.send();\n\nfunction lunrSearch(event) {\n    var query = document.getElementById(\"search-input\").value;\n    var searchResults = document.getElementById(\"search-results\");\n    if (query.length < 3) {\n        searchResults.innerHTML = '';\n    }\n    if ((event.keyCode !== 9) && (query.length > 2)) {\n        var matches = window.index.search(query);\n        displayResults(matches);\n    }\n}\n\nfunction displayResults(results) {\n    var searchResults = document.getElementById('search-results');\n    var inputVal = document.getElementById('search-input').value;\n    if (results.length) {\n        searchResults.innerHTML = '';\n        results.forEach(function(result) {\n            var item = window.searchData[result.ref];\n            var appendString = '<li class=\\\"search-result\\\"><a href=\\\"' + item.url + '\\\"><h5>' + item.title + '</h5>' + '<p>' + item.description + '</p></li>';\n            searchResults.innerHTML += appendString;\n        })\n    } else {\n        searchResults.innerHTML = '<li class=\\\"search-result none\\\">No results found for <span class=\\\"input-value\\\">' + inputVal + '</span>. Please check spelling and spacing.</li>';\n    }\n}\n","document.querySelector('.sidebar-toggle-wrapper').addEventListener('click',navToggle,false);\n\nfunction navToggle() {\n\t$('.sidebar-toggle-wrapper,.site-navigation').toggleClass('open');\n}","document.getElementById('toggle-search').addEventListener('click', toggleSearch, false);\ndocument.getElementById('close-search').addEventListener('click', toggleSearch, false);\n\nfunction toggleSearch(evt) {\n    evt.preventDefault();\n    var searchForm = document.getElementById('site-search');\n    var searchInput = document.getElementById('search-input');\n    searchForm.classList.toggle('open');\n    if (!searchForm.classList.contains('open')) {\n        searchInput.value = '';\n    } else { document.getElementById('search-input').focus(); }\n}\n","(function() {\n    var lunr = function(config) {\n        var idx = new lunr.Index\n\n        idx.pipeline.add(\n            lunr.trimmer,\n            lunr.stopWordFilter,\n            lunr.stemmer\n        )\n\n        if (config) config.call(idx, idx)\n\n        return idx\n    }\n\n    lunr.version = \"0.7.1\"\n    lunr.utils = {}\n    lunr.utils.warn = (function(global) {\n        return function(message) {\n            if (global.console && console.warn) {\n                console.warn(message)\n            }\n        }\n    })(this)\n    lunr.utils.asString = function(obj) {\n            if (obj === void 0 || obj === null) {\n                return \"\"\n            } else {\n                return obj.toString()\n            }\n        }\n    lunr.EventEmitter = function() {\n        this.events = {}\n    }\n\n    /**\n     * Binds a handler function to a specific event(s).\n     *\n     * Can bind a single function to many different events in one call.\n     *\n     * @param {String} [eventName] The name(s) of events to bind this function to.\n     * @param {Function} fn The function to call when an event is fired.\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.addListener = function() {\n        var args = Array.prototype.slice.call(arguments),\n            fn = args.pop(),\n            names = args\n\n        if (typeof fn !== \"function\") throw new TypeError(\"last argument must be a function\")\n\n        names.forEach(function(name) {\n            if (!this.hasHandler(name)) this.events[name] = []\n            this.events[name].push(fn)\n        }, this)\n    }\n\n    /**\n     * Removes a handler function from a specific event.\n     *\n     * @param {String} eventName The name of the event to remove this function from.\n     * @param {Function} fn The function to remove from an event.\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.removeListener = function(name, fn) {\n        if (!this.hasHandler(name)) return\n\n        var fnIndex = this.events[name].indexOf(fn)\n        this.events[name].splice(fnIndex, 1)\n\n        if (!this.events[name].length) delete this.events[name]\n    }\n\n    /**\n     * Calls all functions bound to the given event.\n     *\n     * Additional data can be passed to the event handler as arguments to `emit`\n     * after the event name.\n     *\n     * @param {String} eventName The name of the event to emit.\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.emit = function(name) {\n        if (!this.hasHandler(name)) return\n\n        var args = Array.prototype.slice.call(arguments, 1)\n\n        this.events[name].forEach(function(fn) {\n            fn.apply(undefined, args)\n        })\n    }\n\n    /**\n     * Checks whether a handler has ever been stored against an event.\n     *\n     * @param {String} eventName The name of the event to check.\n     * @private\n     * @memberOf EventEmitter\n     */\n    lunr.EventEmitter.prototype.hasHandler = function(name) {\n        return name in this.events\n    }\n\n    /*!\n     * lunr.tokenizer\n     * Copyright (C) 2016 Oliver Nightingale\n     */\n\n    /**\n     * A function for splitting a string into tokens ready to be inserted into\n     * the search index. Uses `lunr.tokenizer.seperator` to split strings, change\n     * the value of this property to change how strings are split into tokens.\n     *\n     * @module\n     * @param {String} obj The string to convert into tokens\n     * @see lunr.tokenizer.seperator\n     * @returns {Array}\n     */\n    lunr.tokenizer = function(obj) {\n        if (!arguments.length || obj == null || obj == undefined) return []\n        if (Array.isArray(obj)) return obj.map(function(t) {\n            return lunr.utils.asString(t).toLowerCase()\n        })\n\n        return obj.toString().trim().toLowerCase().split(lunr.tokenizer.seperator)\n    }\n\n    /**\n     * The sperator used to split a string into tokens. Override this property to change the behaviour of\n     * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.\n     *\n     * @static\n     * @see lunr.tokenizer\n     */\n    lunr.tokenizer.seperator = /[\\s\\-]+/\n\n    /**\n     * Loads a previously serialised tokenizer.\n     *\n     * A tokenizer function to be loaded must already be registered with lunr.tokenizer.\n     * If the serialised tokenizer has not been registered then an error will be thrown.\n     *\n     * @param {String} label The label of the serialised tokenizer.\n     * @returns {Function}\n     * @memberOf tokenizer\n     */\n    lunr.tokenizer.load = function(label) {\n        var fn = this.registeredFunctions[label]\n\n        if (!fn) {\n            throw new Error('Cannot load un-registered function: ' + label)\n        }\n\n        return fn\n    }\n\n    lunr.tokenizer.label = 'default'\n\n    lunr.tokenizer.registeredFunctions = {\n        'default': lunr.tokenizer\n    }\n\n    /**\n     * Register a tokenizer function.\n     *\n     * Functions that are used as tokenizers should be registered if they are to be used with a serialised index.\n     *\n     * Registering a function does not add it to an index, functions must still be associated with a specific index for them to be used when indexing and searching documents.\n     *\n     * @param {Function} fn The function to register.\n     * @param {String} label The label to register this function with\n     * @memberOf tokenizer\n     */\n    lunr.tokenizer.registerFunction = function(fn, label) {\n            if (label in this.registeredFunctions) {\n                lunr.utils.warn('Overwriting existing tokenizer: ' + label)\n            }\n\n            fn.label = label\n            this.registeredFunctions[label] = fn\n        }\n        /*!\n         * lunr.Pipeline\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.Pipelines maintain an ordered list of functions to be applied to all\n     * tokens in documents entering the search index and queries being ran against\n     * the index.\n     *\n     * An instance of lunr.Index created with the lunr shortcut will contain a\n     * pipeline with a stop word filter and an English language stemmer. Extra\n     * functions can be added before or after either of these functions or these\n     * default functions can be removed.\n     *\n     * When run the pipeline will call each function in turn, passing a token, the\n     * index of that token in the original list of all tokens and finally a list of\n     * all the original tokens.\n     *\n     * The output of functions in the pipeline will be passed to the next function\n     * in the pipeline. To exclude a token from entering the index the function\n     * should return undefined, the rest of the pipeline will not be called with\n     * this token.\n     *\n     * For serialisation of pipelines to work, all functions used in an instance of\n     * a pipeline should be registered with lunr.Pipeline. Registered functions can\n     * then be loaded. If trying to load a serialised pipeline that uses functions\n     * that are not registered an error will be thrown.\n     *\n     * If not planning on serialising the pipeline then registering pipeline functions\n     * is not necessary.\n     *\n     * @constructor\n     */\n    lunr.Pipeline = function() {\n        this._stack = []\n    }\n\n    lunr.Pipeline.registeredFunctions = {}\n\n    /**\n     * Register a function with the pipeline.\n     *\n     * Functions that are used in the pipeline should be registered if the pipeline\n     * needs to be serialised, or a serialised pipeline needs to be loaded.\n     *\n     * Registering a function does not add it to a pipeline, functions must still be\n     * added to instances of the pipeline for them to be used when running a pipeline.\n     *\n     * @param {Function} fn The function to check for.\n     * @param {String} label The label to register this function with\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.registerFunction = function(fn, label) {\n        if (label in this.registeredFunctions) {\n            lunr.utils.warn('Overwriting existing registered function: ' + label)\n        }\n\n        fn.label = label\n        lunr.Pipeline.registeredFunctions[fn.label] = fn\n    }\n\n    /**\n     * Warns if the function is not registered as a Pipeline function.\n     *\n     * @param {Function} fn The function to check for.\n     * @private\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.warnIfFunctionNotRegistered = function(fn) {\n        var isRegistered = fn.label && (fn.label in this.registeredFunctions)\n\n        if (!isRegistered) {\n            lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\\n', fn)\n        }\n    }\n\n    /**\n     * Loads a previously serialised pipeline.\n     *\n     * All functions to be loaded must already be registered with lunr.Pipeline.\n     * If any function from the serialised data has not been registered then an\n     * error will be thrown.\n     *\n     * @param {Object} serialised The serialised pipeline to load.\n     * @returns {lunr.Pipeline}\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.load = function(serialised) {\n        var pipeline = new lunr.Pipeline\n\n        serialised.forEach(function(fnName) {\n            var fn = lunr.Pipeline.registeredFunctions[fnName]\n\n            if (fn) {\n                pipeline.add(fn)\n            } else {\n                throw new Error('Cannot load un-registered function: ' + fnName)\n            }\n        })\n\n        return pipeline\n    }\n\n    /**\n     * Adds new functions to the end of the pipeline.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @param {Function} functions Any number of functions to add to the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.add = function() {\n        var fns = Array.prototype.slice.call(arguments)\n\n        fns.forEach(function(fn) {\n            lunr.Pipeline.warnIfFunctionNotRegistered(fn)\n            this._stack.push(fn)\n        }, this)\n    }\n\n    /**\n     * Adds a single function after a function that already exists in the\n     * pipeline.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @param {Function} existingFn A function that already exists in the pipeline.\n     * @param {Function} newFn The new function to add to the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.after = function(existingFn, newFn) {\n        lunr.Pipeline.warnIfFunctionNotRegistered(newFn)\n\n        var pos = this._stack.indexOf(existingFn)\n        if (pos == -1) {\n            throw new Error('Cannot find existingFn')\n        }\n\n        pos = pos + 1\n        this._stack.splice(pos, 0, newFn)\n    }\n\n    /**\n     * Adds a single function before a function that already exists in the\n     * pipeline.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @param {Function} existingFn A function that already exists in the pipeline.\n     * @param {Function} newFn The new function to add to the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.before = function(existingFn, newFn) {\n        lunr.Pipeline.warnIfFunctionNotRegistered(newFn)\n\n        var pos = this._stack.indexOf(existingFn)\n        if (pos == -1) {\n            throw new Error('Cannot find existingFn')\n        }\n\n        this._stack.splice(pos, 0, newFn)\n    }\n\n    /**\n     * Removes a function from the pipeline.\n     *\n     * @param {Function} fn The function to remove from the pipeline.\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.remove = function(fn) {\n        var pos = this._stack.indexOf(fn)\n        if (pos == -1) {\n            return\n        }\n\n        this._stack.splice(pos, 1)\n    }\n\n    /**\n     * Runs the current list of functions that make up the pipeline against the\n     * passed tokens.\n     *\n     * @param {Array} tokens The tokens to run through the pipeline.\n     * @returns {Array}\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.run = function(tokens) {\n        var out = [],\n            tokenLength = tokens.length,\n            stackLength = this._stack.length\n\n        for (var i = 0; i < tokenLength; i++) {\n            var token = tokens[i]\n\n            for (var j = 0; j < stackLength; j++) {\n                token = this._stack[j](token, i, tokens)\n                if (token === void 0 || token === '') break\n            };\n\n            if (token !== void 0 && token !== '') out.push(token)\n        };\n\n        return out\n    }\n\n    /**\n     * Resets the pipeline by removing any existing processors.\n     *\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.reset = function() {\n        this._stack = []\n    }\n\n    /**\n     * Returns a representation of the pipeline ready for serialisation.\n     *\n     * Logs a warning if the function has not been registered.\n     *\n     * @returns {Array}\n     * @memberOf Pipeline\n     */\n    lunr.Pipeline.prototype.toJSON = function() {\n            return this._stack.map(function(fn) {\n                lunr.Pipeline.warnIfFunctionNotRegistered(fn)\n\n                return fn.label\n            })\n        }\n        /*!\n         * lunr.Vector\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.Vectors implement vector related operations for\n     * a series of elements.\n     *\n     * @constructor\n     */\n    lunr.Vector = function() {\n        this._magnitude = null\n        this.list = undefined\n        this.length = 0\n    }\n\n    /**\n     * lunr.Vector.Node is a simple struct for each node\n     * in a lunr.Vector.\n     *\n     * @private\n     * @param {Number} The index of the node in the vector.\n     * @param {Object} The data at this node in the vector.\n     * @param {lunr.Vector.Node} The node directly after this node in the vector.\n     * @constructor\n     * @memberOf Vector\n     */\n    lunr.Vector.Node = function(idx, val, next) {\n        this.idx = idx\n        this.val = val\n        this.next = next\n    }\n\n    /**\n     * Inserts a new value at a position in a vector.\n     *\n     * @param {Number} The index at which to insert a value.\n     * @param {Object} The object to insert in the vector.\n     * @memberOf Vector.\n     */\n    lunr.Vector.prototype.insert = function(idx, val) {\n        this._magnitude = undefined;\n        var list = this.list\n\n        if (!list) {\n            this.list = new lunr.Vector.Node(idx, val, list)\n            return this.length++\n        }\n\n        if (idx < list.idx) {\n            this.list = new lunr.Vector.Node(idx, val, list)\n            return this.length++\n        }\n\n        var prev = list,\n            next = list.next\n\n        while (next != undefined) {\n            if (idx < next.idx) {\n                prev.next = new lunr.Vector.Node(idx, val, next)\n                return this.length++\n            }\n\n            prev = next, next = next.next\n        }\n\n        prev.next = new lunr.Vector.Node(idx, val, next)\n        return this.length++\n    }\n\n    /**\n     * Calculates the magnitude of this vector.\n     *\n     * @returns {Number}\n     * @memberOf Vector\n     */\n    lunr.Vector.prototype.magnitude = function() {\n        if (this._magnitude) return this._magnitude\n        var node = this.list,\n            sumOfSquares = 0,\n            val\n\n        while (node) {\n            val = node.val\n            sumOfSquares += val * val\n            node = node.next\n        }\n\n        return this._magnitude = Math.sqrt(sumOfSquares)\n    }\n\n    /**\n     * Calculates the dot product of this vector and another vector.\n     *\n     * @param {lunr.Vector} otherVector The vector to compute the dot product with.\n     * @returns {Number}\n     * @memberOf Vector\n     */\n    lunr.Vector.prototype.dot = function(otherVector) {\n        var node = this.list,\n            otherNode = otherVector.list,\n            dotProduct = 0\n\n        while (node && otherNode) {\n            if (node.idx < otherNode.idx) {\n                node = node.next\n            } else if (node.idx > otherNode.idx) {\n                otherNode = otherNode.next\n            } else {\n                dotProduct += node.val * otherNode.val\n                node = node.next\n                otherNode = otherNode.next\n            }\n        }\n\n        return dotProduct\n    }\n\n    /**\n     * Calculates the cosine similarity between this vector and another\n     * vector.\n     *\n     * @param {lunr.Vector} otherVector The other vector to calculate the\n     * similarity with.\n     * @returns {Number}\n     * @memberOf Vector\n     */\n    lunr.Vector.prototype.similarity = function(otherVector) {\n            return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())\n        }\n        /*!\n         * lunr.SortedSet\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.SortedSets are used to maintain an array of uniq values in a sorted\n     * order.\n     *\n     * @constructor\n     */\n    lunr.SortedSet = function() {\n        this.length = 0\n        this.elements = []\n    }\n\n    /**\n     * Loads a previously serialised sorted set.\n     *\n     * @param {Array} serialisedData The serialised set to load.\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.load = function(serialisedData) {\n        var set = new this\n\n        set.elements = serialisedData\n        set.length = serialisedData.length\n\n        return set\n    }\n\n    /**\n     * Inserts new items into the set in the correct position to maintain the\n     * order.\n     *\n     * @param {Object} The objects to add to this set.\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.add = function() {\n        var i, element\n\n        for (i = 0; i < arguments.length; i++) {\n            element = arguments[i]\n            if (~this.indexOf(element)) continue\n            this.elements.splice(this.locationFor(element), 0, element)\n        }\n\n        this.length = this.elements.length\n    }\n\n    /**\n     * Converts this sorted set into an array.\n     *\n     * @returns {Array}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.toArray = function() {\n        return this.elements.slice()\n    }\n\n    /**\n     * Creates a new array with the results of calling a provided function on every\n     * element in this sorted set.\n     *\n     * Delegates to Array.prototype.map and has the same signature.\n     *\n     * @param {Function} fn The function that is called on each element of the\n     * set.\n     * @param {Object} ctx An optional object that can be used as the context\n     * for the function fn.\n     * @returns {Array}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.map = function(fn, ctx) {\n        return this.elements.map(fn, ctx)\n    }\n\n    /**\n     * Executes a provided function once per sorted set element.\n     *\n     * Delegates to Array.prototype.forEach and has the same signature.\n     *\n     * @param {Function} fn The function that is called on each element of the\n     * set.\n     * @param {Object} ctx An optional object that can be used as the context\n     * @memberOf SortedSet\n     * for the function fn.\n     */\n    lunr.SortedSet.prototype.forEach = function(fn, ctx) {\n        return this.elements.forEach(fn, ctx)\n    }\n\n    /**\n     * Returns the index at which a given element can be found in the\n     * sorted set, or -1 if it is not present.\n     *\n     * @param {Object} elem The object to locate in the sorted set.\n     * @returns {Number}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.indexOf = function(elem) {\n        var start = 0,\n            end = this.elements.length,\n            sectionLength = end - start,\n            pivot = start + Math.floor(sectionLength / 2),\n            pivotElem = this.elements[pivot]\n\n        while (sectionLength > 1) {\n            if (pivotElem === elem) return pivot\n\n            if (pivotElem < elem) start = pivot\n            if (pivotElem > elem) end = pivot\n\n            sectionLength = end - start\n            pivot = start + Math.floor(sectionLength / 2)\n            pivotElem = this.elements[pivot]\n        }\n\n        if (pivotElem === elem) return pivot\n\n        return -1\n    }\n\n    /**\n     * Returns the position within the sorted set that an element should be\n     * inserted at to maintain the current order of the set.\n     *\n     * This function assumes that the element to search for does not already exist\n     * in the sorted set.\n     *\n     * @param {Object} elem The elem to find the position for in the set\n     * @returns {Number}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.locationFor = function(elem) {\n        var start = 0,\n            end = this.elements.length,\n            sectionLength = end - start,\n            pivot = start + Math.floor(sectionLength / 2),\n            pivotElem = this.elements[pivot]\n\n        while (sectionLength > 1) {\n            if (pivotElem < elem) start = pivot\n            if (pivotElem > elem) end = pivot\n\n            sectionLength = end - start\n            pivot = start + Math.floor(sectionLength / 2)\n            pivotElem = this.elements[pivot]\n        }\n\n        if (pivotElem > elem) return pivot\n        if (pivotElem < elem) return pivot + 1\n    }\n\n    /**\n     * Creates a new lunr.SortedSet that contains the elements in the intersection\n     * of this set and the passed set.\n     *\n     * @param {lunr.SortedSet} otherSet The set to intersect with this set.\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.intersect = function(otherSet) {\n        var intersectSet = new lunr.SortedSet,\n            i = 0,\n            j = 0,\n            a_len = this.length,\n            b_len = otherSet.length,\n            a = this.elements,\n            b = otherSet.elements\n\n        while (true) {\n            if (i > a_len - 1 || j > b_len - 1) break\n\n            if (a[i] === b[j]) {\n                intersectSet.add(a[i])\n                i++, j++\n                continue\n            }\n\n            if (a[i] < b[j]) {\n                i++\n                continue\n            }\n\n            if (a[i] > b[j]) {\n                j++\n                continue\n            }\n        };\n\n        return intersectSet\n    }\n\n    /**\n     * Makes a copy of this set\n     *\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.clone = function() {\n        var clone = new lunr.SortedSet\n\n        clone.elements = this.toArray()\n        clone.length = clone.elements.length\n\n        return clone\n    }\n\n    /**\n     * Creates a new lunr.SortedSet that contains the elements in the union\n     * of this set and the passed set.\n     *\n     * @param {lunr.SortedSet} otherSet The set to union with this set.\n     * @returns {lunr.SortedSet}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.union = function(otherSet) {\n        var longSet, shortSet, unionSet\n\n        if (this.length >= otherSet.length) {\n            longSet = this, shortSet = otherSet\n        } else {\n            longSet = otherSet, shortSet = this\n        }\n\n        unionSet = longSet.clone()\n\n        for (var i = 0, shortSetElements = shortSet.toArray(); i < shortSetElements.length; i++) {\n            unionSet.add(shortSetElements[i])\n        }\n\n        return unionSet\n    }\n\n    /**\n     * Returns a representation of the sorted set ready for serialisation.\n     *\n     * @returns {Array}\n     * @memberOf SortedSet\n     */\n    lunr.SortedSet.prototype.toJSON = function() {\n            return this.toArray()\n        }\n        /*!\n         * lunr.Index\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.Index is object that manages a search index.  It contains the indexes\n     * and stores all the tokens and document lookups.  It also provides the main\n     * user facing API for the library.\n     *\n     * @constructor\n     */\n    lunr.Index = function() {\n        this._fields = []\n        this._ref = 'id'\n        this.pipeline = new lunr.Pipeline\n        this.documentStore = new lunr.Store\n        this.tokenStore = new lunr.TokenStore\n        this.corpusTokens = new lunr.SortedSet\n        this.eventEmitter = new lunr.EventEmitter\n        this.tokenizerFn = lunr.tokenizer\n\n        this._idfCache = {}\n\n        this.on('add', 'remove', 'update', (function() {\n            this._idfCache = {}\n        }).bind(this))\n    }\n\n    /**\n     * Bind a handler to events being emitted by the index.\n     *\n     * The handler can be bound to many events at the same time.\n     *\n     * @param {String} [eventName] The name(s) of events to bind the function to.\n     * @param {Function} fn The serialised set to load.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.on = function() {\n        var args = Array.prototype.slice.call(arguments)\n        return this.eventEmitter.addListener.apply(this.eventEmitter, args)\n    }\n\n    /**\n     * Removes a handler from an event being emitted by the index.\n     *\n     * @param {String} eventName The name of events to remove the function from.\n     * @param {Function} fn The serialised set to load.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.off = function(name, fn) {\n        return this.eventEmitter.removeListener(name, fn)\n    }\n\n    /**\n     * Loads a previously serialised index.\n     *\n     * Issues a warning if the index being imported was serialised\n     * by a different version of lunr.\n     *\n     * @param {Object} serialisedData The serialised set to load.\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.load = function(serialisedData) {\n        if (serialisedData.version !== lunr.version) {\n            lunr.utils.warn('version mismatch: current ' + lunr.version + ' importing ' + serialisedData.version)\n        }\n\n        var idx = new this\n\n        idx._fields = serialisedData.fields\n        idx._ref = serialisedData.ref\n\n        idx.tokenizer = lunr.tokenizer.load(serialisedData.tokenizer)\n        idx.documentStore = lunr.Store.load(serialisedData.documentStore)\n        idx.tokenStore = lunr.TokenStore.load(serialisedData.tokenStore)\n        idx.corpusTokens = lunr.SortedSet.load(serialisedData.corpusTokens)\n        idx.pipeline = lunr.Pipeline.load(serialisedData.pipeline)\n\n        return idx\n    }\n\n    /**\n     * Adds a field to the list of fields that will be searchable within documents\n     * in the index.\n     *\n     * An optional boost param can be passed to affect how much tokens in this field\n     * rank in search results, by default the boost value is 1.\n     *\n     * Fields should be added before any documents are added to the index, fields\n     * that are added after documents are added to the index will only apply to new\n     * documents added to the index.\n     *\n     * @param {String} fieldName The name of the field within the document that\n     * should be indexed\n     * @param {Number} boost An optional boost that can be applied to terms in this\n     * field.\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.field = function(fieldName, opts) {\n        var opts = opts || {},\n            field = { name: fieldName, boost: opts.boost || 1 }\n\n        this._fields.push(field)\n        return this\n    }\n\n    /**\n     * Sets the property used to uniquely identify documents added to the index,\n     * by default this property is 'id'.\n     *\n     * This should only be changed before adding documents to the index, changing\n     * the ref property without resetting the index can lead to unexpected results.\n     *\n     * The value of ref can be of any type but it _must_ be stably comparable and\n     * orderable.\n     *\n     * @param {String} refName The property to use to uniquely identify the\n     * documents in the index.\n     * @param {Boolean} emitEvent Whether to emit add events, defaults to true\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.ref = function(refName) {\n        this._ref = refName\n        return this\n    }\n\n    /**\n     * Sets the tokenizer used for this index.\n     *\n     * By default the index will use the default tokenizer, lunr.tokenizer. The tokenizer\n     * should only be changed before adding documents to the index. Changing the tokenizer\n     * without re-building the index can lead to unexpected results.\n     *\n     * @param {Function} fn The function to use as a tokenizer.\n     * @returns {lunr.Index}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.tokenizer = function(fn) {\n        var isRegistered = fn.label && (fn.label in lunr.tokenizer.registeredFunctions)\n\n        if (!isRegistered) {\n            lunr.utils.warn('Function is not a registered tokenizer. This may cause problems when serialising the index')\n        }\n\n        this.tokenizerFn = fn\n        return this\n    }\n\n    /**\n     * Add a document to the index.\n     *\n     * This is the way new documents enter the index, this function will run the\n     * fields from the document through the index's pipeline and then add it to\n     * the index, it will then show up in search results.\n     *\n     * An 'add' event is emitted with the document that has been added and the index\n     * the document has been added to. This event can be silenced by passing false\n     * as the second argument to add.\n     *\n     * @param {Object} doc The document to add to the index.\n     * @param {Boolean} emitEvent Whether or not to emit events, default true.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.add = function(doc, emitEvent) {\n        var docTokens = {},\n            allDocumentTokens = new lunr.SortedSet,\n            docRef = doc[this._ref],\n            emitEvent = emitEvent === undefined ? true : emitEvent\n\n        this._fields.forEach(function(field) {\n            var fieldTokens = this.pipeline.run(this.tokenizerFn(doc[field.name]))\n\n            docTokens[field.name] = fieldTokens\n\n            for (var i = 0; i < fieldTokens.length; i++) {\n                var token = fieldTokens[i]\n                allDocumentTokens.add(token)\n                this.corpusTokens.add(token)\n            }\n        }, this)\n\n        this.documentStore.set(docRef, allDocumentTokens)\n\n        for (var i = 0; i < allDocumentTokens.length; i++) {\n            var token = allDocumentTokens.elements[i]\n            var tf = 0;\n\n            for (var j = 0; j < this._fields.length; j++) {\n                var field = this._fields[j]\n                var fieldTokens = docTokens[field.name]\n                var fieldLength = fieldTokens.length\n\n                if (!fieldLength) continue\n\n                var tokenCount = 0\n                for (var k = 0; k < fieldLength; k++) {\n                    if (fieldTokens[k] === token) {\n                        tokenCount++\n                    }\n                }\n\n                tf += (tokenCount / fieldLength * field.boost)\n            }\n\n            this.tokenStore.add(token, { ref: docRef, tf: tf })\n        };\n\n        if (emitEvent) this.eventEmitter.emit('add', doc, this)\n    }\n\n    /**\n     * Removes a document from the index.\n     *\n     * To make sure documents no longer show up in search results they can be\n     * removed from the index using this method.\n     *\n     * The document passed only needs to have the same ref property value as the\n     * document that was added to the index, they could be completely different\n     * objects.\n     *\n     * A 'remove' event is emitted with the document that has been removed and the index\n     * the document has been removed from. This event can be silenced by passing false\n     * as the second argument to remove.\n     *\n     * @param {Object} doc The document to remove from the index.\n     * @param {Boolean} emitEvent Whether to emit remove events, defaults to true\n     * @memberOf Index\n     */\n    lunr.Index.prototype.remove = function(doc, emitEvent) {\n        var docRef = doc[this._ref],\n            emitEvent = emitEvent === undefined ? true : emitEvent\n\n        if (!this.documentStore.has(docRef)) return\n\n        var docTokens = this.documentStore.get(docRef)\n\n        this.documentStore.remove(docRef)\n\n        docTokens.forEach(function(token) {\n            this.tokenStore.remove(token, docRef)\n        }, this)\n\n        if (emitEvent) this.eventEmitter.emit('remove', doc, this)\n    }\n\n    /**\n     * Updates a document in the index.\n     *\n     * When a document contained within the index gets updated, fields changed,\n     * added or removed, to make sure it correctly matched against search queries,\n     * it should be updated in the index.\n     *\n     * This method is just a wrapper around `remove` and `add`\n     *\n     * An 'update' event is emitted with the document that has been updated and the index.\n     * This event can be silenced by passing false as the second argument to update. Only\n     * an update event will be fired, the 'add' and 'remove' events of the underlying calls\n     * are silenced.\n     *\n     * @param {Object} doc The document to update in the index.\n     * @param {Boolean} emitEvent Whether to emit update events, defaults to true\n     * @see Index.prototype.remove\n     * @see Index.prototype.add\n     * @memberOf Index\n     */\n    lunr.Index.prototype.update = function(doc, emitEvent) {\n        var emitEvent = emitEvent === undefined ? true : emitEvent\n\n        this.remove(doc, false)\n        this.add(doc, false)\n\n        if (emitEvent) this.eventEmitter.emit('update', doc, this)\n    }\n\n    /**\n     * Calculates the inverse document frequency for a token within the index.\n     *\n     * @param {String} token The token to calculate the idf of.\n     * @see Index.prototype.idf\n     * @private\n     * @memberOf Index\n     */\n    lunr.Index.prototype.idf = function(term) {\n        var cacheKey = \"@\" + term\n        if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey]\n\n        var documentFrequency = this.tokenStore.count(term),\n            idf = 1\n\n        if (documentFrequency > 0) {\n            idf = 1 + Math.log(this.documentStore.length / documentFrequency)\n        }\n\n        return this._idfCache[cacheKey] = idf\n    }\n\n    /**\n     * Searches the index using the passed query.\n     *\n     * Queries should be a string, multiple words are allowed and will lead to an\n     * AND based query, e.g. `idx.search('foo bar')` will run a search for\n     * documents containing both 'foo' and 'bar'.\n     *\n     * All query tokens are passed through the same pipeline that document tokens\n     * are passed through, so any language processing involved will be run on every\n     * query term.\n     *\n     * Each query term is expanded, so that the term 'he' might be expanded to\n     * 'hello' and 'help' if those terms were already included in the index.\n     *\n     * Matching documents are returned as an array of objects, each object contains\n     * the matching document ref, as set for this index, and the similarity score\n     * for this document against the query.\n     *\n     * @param {String} query The query to search the index with.\n     * @returns {Object}\n     * @see Index.prototype.idf\n     * @see Index.prototype.documentVector\n     * @memberOf Index\n     */\n    lunr.Index.prototype.search = function(query) {\n        var queryTokens = this.pipeline.run(this.tokenizerFn(query)),\n            queryVector = new lunr.Vector,\n            documentSets = [],\n            fieldBoosts = this._fields.reduce(function(memo, f) {\n                return memo + f.boost\n            }, 0)\n\n        var hasSomeToken = queryTokens.some(function(token) {\n            return this.tokenStore.has(token)\n        }, this)\n\n        if (!hasSomeToken) return []\n\n        queryTokens\n            .forEach(function(token, i, tokens) {\n                var tf = 1 / tokens.length * this._fields.length * fieldBoosts,\n                    self = this\n\n                var set = this.tokenStore.expand(token).reduce(function(memo, key) {\n                    var pos = self.corpusTokens.indexOf(key),\n                        idf = self.idf(key),\n                        similarityBoost = 1,\n                        set = new lunr.SortedSet\n\n                    // if the expanded key is not an exact match to the token then\n                    // penalise the score for this key by how different the key is\n                    // to the token.\n                    if (key !== token) {\n                        var diff = Math.max(3, key.length - token.length)\n                        similarityBoost = 1 / Math.log(diff)\n                    }\n\n                    // calculate the query tf-idf score for this token\n                    // applying an similarityBoost to ensure exact matches\n                    // these rank higher than expanded terms\n                    if (pos > -1) queryVector.insert(pos, tf * idf * similarityBoost)\n\n                    // add all the documents that have this key into a set\n                    // ensuring that the type of key is preserved\n                    var matchingDocuments = self.tokenStore.get(key),\n                        refs = Object.keys(matchingDocuments),\n                        refsLen = refs.length\n\n                    for (var i = 0; i < refsLen; i++) {\n                        set.add(matchingDocuments[refs[i]].ref)\n                    }\n\n                    return memo.union(set)\n                }, new lunr.SortedSet)\n\n                documentSets.push(set)\n            }, this)\n\n        var documentSet = documentSets.reduce(function(memo, set) {\n            return memo.intersect(set)\n        })\n\n        return documentSet\n            .map(function(ref) {\n                return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) }\n            }, this)\n            .sort(function(a, b) {\n                return b.score - a.score\n            })\n    }\n\n    /**\n     * Generates a vector containing all the tokens in the document matching the\n     * passed documentRef.\n     *\n     * The vector contains the tf-idf score for each token contained in the\n     * document with the passed documentRef.  The vector will contain an element\n     * for every token in the indexes corpus, if the document does not contain that\n     * token the element will be 0.\n     *\n     * @param {Object} documentRef The ref to find the document with.\n     * @returns {lunr.Vector}\n     * @private\n     * @memberOf Index\n     */\n    lunr.Index.prototype.documentVector = function(documentRef) {\n        var documentTokens = this.documentStore.get(documentRef),\n            documentTokensLength = documentTokens.length,\n            documentVector = new lunr.Vector\n\n        for (var i = 0; i < documentTokensLength; i++) {\n            var token = documentTokens.elements[i],\n                tf = this.tokenStore.get(token)[documentRef].tf,\n                idf = this.idf(token)\n\n            documentVector.insert(this.corpusTokens.indexOf(token), tf * idf)\n        };\n\n        return documentVector\n    }\n\n    /**\n     * Returns a representation of the index ready for serialisation.\n     *\n     * @returns {Object}\n     * @memberOf Index\n     */\n    lunr.Index.prototype.toJSON = function() {\n        return {\n            version: lunr.version,\n            fields: this._fields,\n            ref: this._ref,\n            tokenizer: this.tokenizerFn.label,\n            documentStore: this.documentStore.toJSON(),\n            tokenStore: this.tokenStore.toJSON(),\n            corpusTokens: this.corpusTokens.toJSON(),\n            pipeline: this.pipeline.toJSON()\n        }\n    }\n\n    /**\n     * Applies a plugin to the current index.\n     *\n     * A plugin is a function that is called with the index as its context.\n     * Plugins can be used to customise or extend the behaviour the index\n     * in some way. A plugin is just a function, that encapsulated the custom\n     * behaviour that should be applied to the index.\n     *\n     * The plugin function will be called with the index as its argument, additional\n     * arguments can also be passed when calling use. The function will be called\n     * with the index as its context.\n     *\n     * Example:\n     *\n     *     var myPlugin = function (idx, arg1, arg2) {\n     *       // `this` is the index to be extended\n     *       // apply any extensions etc here.\n     *     }\n     *\n     *     var idx = lunr(function () {\n     *       this.use(myPlugin, 'arg1', 'arg2')\n     *     })\n     *\n     * @param {Function} plugin The plugin to apply.\n     * @memberOf Index\n     */\n    lunr.Index.prototype.use = function(plugin) {\n            var args = Array.prototype.slice.call(arguments, 1)\n            args.unshift(this)\n            plugin.apply(this, args)\n        }\n        /*!\n         * lunr.Store\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.Store is a simple key-value store used for storing sets of tokens for\n     * documents stored in index.\n     *\n     * @constructor\n     * @module\n     */\n    lunr.Store = function() {\n        this.store = {}\n        this.length = 0\n    }\n\n    /**\n     * Loads a previously serialised store\n     *\n     * @param {Object} serialisedData The serialised store to load.\n     * @returns {lunr.Store}\n     * @memberOf Store\n     */\n    lunr.Store.load = function(serialisedData) {\n        var store = new this\n\n        store.length = serialisedData.length\n        store.store = Object.keys(serialisedData.store).reduce(function(memo, key) {\n            memo[key] = lunr.SortedSet.load(serialisedData.store[key])\n            return memo\n        }, {})\n\n        return store\n    }\n\n    /**\n     * Stores the given tokens in the store against the given id.\n     *\n     * @param {Object} id The key used to store the tokens against.\n     * @param {Object} tokens The tokens to store against the key.\n     * @memberOf Store\n     */\n    lunr.Store.prototype.set = function(id, tokens) {\n        if (!this.has(id)) this.length++\n            this.store[id] = tokens\n    }\n\n    /**\n     * Retrieves the tokens from the store for a given key.\n     *\n     * @param {Object} id The key to lookup and retrieve from the store.\n     * @returns {Object}\n     * @memberOf Store\n     */\n    lunr.Store.prototype.get = function(id) {\n        return this.store[id]\n    }\n\n    /**\n     * Checks whether the store contains a key.\n     *\n     * @param {Object} id The id to look up in the store.\n     * @returns {Boolean}\n     * @memberOf Store\n     */\n    lunr.Store.prototype.has = function(id) {\n        return id in this.store\n    }\n\n    /**\n     * Removes the value for a key in the store.\n     *\n     * @param {Object} id The id to remove from the store.\n     * @memberOf Store\n     */\n    lunr.Store.prototype.remove = function(id) {\n        if (!this.has(id)) return\n\n        delete this.store[id]\n        this.length--\n    }\n\n    /**\n     * Returns a representation of the store ready for serialisation.\n     *\n     * @returns {Object}\n     * @memberOf Store\n     */\n    lunr.Store.prototype.toJSON = function() {\n        return {\n            store: this.store,\n            length: this.length\n        }\n    }\n\n    /*!\n     * lunr.stemmer\n     * Copyright (C) 2016 Oliver Nightingale\n     * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n     */\n\n    /**\n     * lunr.stemmer is an english language stemmer, this is a JavaScript\n     * implementation of the PorterStemmer taken from http://tartarus.org/~martin\n     *\n     * @module\n     * @param {String} str The string to stem\n     * @returns {String}\n     * @see lunr.Pipeline\n     */\n    lunr.stemmer = (function() {\n        var step2list = {\n                \"ational\": \"ate\",\n                \"tional\": \"tion\",\n                \"enci\": \"ence\",\n                \"anci\": \"ance\",\n                \"izer\": \"ize\",\n                \"bli\": \"ble\",\n                \"alli\": \"al\",\n                \"entli\": \"ent\",\n                \"eli\": \"e\",\n                \"ousli\": \"ous\",\n                \"ization\": \"ize\",\n                \"ation\": \"ate\",\n                \"ator\": \"ate\",\n                \"alism\": \"al\",\n                \"iveness\": \"ive\",\n                \"fulness\": \"ful\",\n                \"ousness\": \"ous\",\n                \"aliti\": \"al\",\n                \"iviti\": \"ive\",\n                \"biliti\": \"ble\",\n                \"logi\": \"log\"\n            },\n\n            step3list = {\n                \"icate\": \"ic\",\n                \"ative\": \"\",\n                \"alize\": \"al\",\n                \"iciti\": \"ic\",\n                \"ical\": \"ic\",\n                \"ful\": \"\",\n                \"ness\": \"\"\n            },\n\n            c = \"[^aeiou]\", // consonant\n            v = \"[aeiouy]\", // vowel\n            C = c + \"[^aeiouy]*\", // consonant sequence\n            V = v + \"[aeiou]*\", // vowel sequence\n\n            mgr0 = \"^(\" + C + \")?\" + V + C, // [C]VC... is m>0\n            meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\", // [C]VC[V] is m=1\n            mgr1 = \"^(\" + C + \")?\" + V + C + V + C, // [C]VCVC... is m>1\n            s_v = \"^(\" + C + \")?\" + v; // vowel in stem\n\n        var re_mgr0 = new RegExp(mgr0);\n        var re_mgr1 = new RegExp(mgr1);\n        var re_meq1 = new RegExp(meq1);\n        var re_s_v = new RegExp(s_v);\n\n        var re_1a = /^(.+?)(ss|i)es$/;\n        var re2_1a = /^(.+?)([^s])s$/;\n        var re_1b = /^(.+?)eed$/;\n        var re2_1b = /^(.+?)(ed|ing)$/;\n        var re_1b_2 = /.$/;\n        var re2_1b_2 = /(at|bl|iz)$/;\n        var re3_1b_2 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n        var re4_1b_2 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n        var re_1c = /^(.+?[^aeiou])y$/;\n        var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n\n        var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n\n        var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n        var re2_4 = /^(.+?)(s|t)(ion)$/;\n\n        var re_5 = /^(.+?)e$/;\n        var re_5_1 = /ll$/;\n        var re3_5 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n        var porterStemmer = function porterStemmer(w) {\n            var stem,\n                suffix,\n                firstch,\n                re,\n                re2,\n                re3,\n                re4;\n\n            if (w.length < 3) {\n                return w;\n            }\n\n            firstch = w.substr(0, 1);\n            if (firstch == \"y\") {\n                w = firstch.toUpperCase() + w.substr(1);\n            }\n\n            // Step 1a\n            re = re_1a\n            re2 = re2_1a;\n\n            if (re.test(w)) { w = w.replace(re, \"$1$2\"); } else if (re2.test(w)) { w = w.replace(re2, \"$1$2\"); }\n\n            // Step 1b\n            re = re_1b;\n            re2 = re2_1b;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                re = re_mgr0;\n                if (re.test(fp[1])) {\n                    re = re_1b_2;\n                    w = w.replace(re, \"\");\n                }\n            } else if (re2.test(w)) {\n                var fp = re2.exec(w);\n                stem = fp[1];\n                re2 = re_s_v;\n                if (re2.test(stem)) {\n                    w = stem;\n                    re2 = re2_1b_2;\n                    re3 = re3_1b_2;\n                    re4 = re4_1b_2;\n                    if (re2.test(w)) { w = w + \"e\"; } else if (re3.test(w)) {\n                        re = re_1b_2;\n                        w = w.replace(re, \"\");\n                    } else if (re4.test(w)) { w = w + \"e\"; }\n                }\n            }\n\n            // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)\n            re = re_1c;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                w = stem + \"i\";\n            }\n\n            // Step 2\n            re = re_2;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                suffix = fp[2];\n                re = re_mgr0;\n                if (re.test(stem)) {\n                    w = stem + step2list[suffix];\n                }\n            }\n\n            // Step 3\n            re = re_3;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                suffix = fp[2];\n                re = re_mgr0;\n                if (re.test(stem)) {\n                    w = stem + step3list[suffix];\n                }\n            }\n\n            // Step 4\n            re = re_4;\n            re2 = re2_4;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                re = re_mgr1;\n                if (re.test(stem)) {\n                    w = stem;\n                }\n            } else if (re2.test(w)) {\n                var fp = re2.exec(w);\n                stem = fp[1] + fp[2];\n                re2 = re_mgr1;\n                if (re2.test(stem)) {\n                    w = stem;\n                }\n            }\n\n            // Step 5\n            re = re_5;\n            if (re.test(w)) {\n                var fp = re.exec(w);\n                stem = fp[1];\n                re = re_mgr1;\n                re2 = re_meq1;\n                re3 = re3_5;\n                if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {\n                    w = stem;\n                }\n            }\n\n            re = re_5_1;\n            re2 = re_mgr1;\n            if (re.test(w) && re2.test(w)) {\n                re = re_1b_2;\n                w = w.replace(re, \"\");\n            }\n\n            // and turn initial Y back to y\n\n            if (firstch == \"y\") {\n                w = firstch.toLowerCase() + w.substr(1);\n            }\n\n            return w;\n        };\n\n        return porterStemmer;\n    })();\n\n    lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')\n        /*!\n         * lunr.stopWordFilter\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.generateStopWordFilter builds a stopWordFilter function from the provided\n     * list of stop words.\n     *\n     * The built in lunr.stopWordFilter is built using this generator and can be used\n     * to generate custom stopWordFilters for applications or non English languages.\n     *\n     * @module\n     * @param {Array} token The token to pass through the filter\n     * @returns {Function}\n     * @see lunr.Pipeline\n     * @see lunr.stopWordFilter\n     */\n    lunr.generateStopWordFilter = function(stopWords) {\n        var words = stopWords.reduce(function(memo, stopWord) {\n            memo[stopWord] = stopWord\n            return memo\n        }, {})\n\n        return function(token) {\n            if (token && words[token] !== token) return token\n        }\n    }\n\n    /**\n     * lunr.stopWordFilter is an English language stop word list filter, any words\n     * contained in the list will not be passed through the filter.\n     *\n     * This is intended to be used in the Pipeline. If the token does not pass the\n     * filter then undefined will be returned.\n     *\n     * @module\n     * @param {String} token The token to pass through the filter\n     * @returns {String}\n     * @see lunr.Pipeline\n     */\n    lunr.stopWordFilter = lunr.generateStopWordFilter([\n        'a',\n        'able',\n        'about',\n        'across',\n        'after',\n        'all',\n        'almost',\n        'also',\n        'am',\n        'among',\n        'an',\n        'and',\n        'any',\n        'are',\n        'as',\n        'at',\n        'be',\n        'because',\n        'been',\n        'but',\n        'by',\n        'can',\n        'cannot',\n        'could',\n        'dear',\n        'did',\n        'do',\n        'does',\n        'either',\n        'else',\n        'ever',\n        'every',\n        'for',\n        'from',\n        'get',\n        'got',\n        'had',\n        'has',\n        'have',\n        'he',\n        'her',\n        'hers',\n        'him',\n        'his',\n        'how',\n        'however',\n        'i',\n        'if',\n        'in',\n        'into',\n        'is',\n        'it',\n        'its',\n        'just',\n        'least',\n        'let',\n        'like',\n        'likely',\n        'may',\n        'me',\n        'might',\n        'most',\n        'must',\n        'my',\n        'neither',\n        'no',\n        'nor',\n        'not',\n        'of',\n        'off',\n        'often',\n        'on',\n        'only',\n        'or',\n        'other',\n        'our',\n        'own',\n        'rather',\n        'said',\n        'say',\n        'says',\n        'she',\n        'should',\n        'since',\n        'so',\n        'some',\n        'than',\n        'that',\n        'the',\n        'their',\n        'them',\n        'then',\n        'there',\n        'these',\n        'they',\n        'this',\n        'tis',\n        'to',\n        'too',\n        'twas',\n        'us',\n        'wants',\n        'was',\n        'we',\n        'were',\n        'what',\n        'when',\n        'where',\n        'which',\n        'while',\n        'who',\n        'whom',\n        'why',\n        'will',\n        'with',\n        'would',\n        'yet',\n        'you',\n        'your'\n    ])\n\n    lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')\n        /*!\n         * lunr.trimmer\n         * Copyright (C) 2016 Oliver Nightingale\n         */\n\n    /**\n     * lunr.trimmer is a pipeline function for trimming non word\n     * characters from the begining and end of tokens before they\n     * enter the index.\n     *\n     * This implementation may not work correctly for non latin\n     * characters and should either be removed or adapted for use\n     * with languages with non-latin characters.\n     *\n     * @module\n     * @param {String} token The token to pass through the filter\n     * @returns {String}\n     * @see lunr.Pipeline\n     */\n    lunr.trimmer = function(token) {\n        return token.replace(/^\\W+/, '').replace(/\\W+$/, '')\n    }\n\n    lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer')\n        /*!\n         * lunr.stemmer\n         * Copyright (C) 2016 Oliver Nightingale\n         * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n         */\n\n    /**\n     * lunr.TokenStore is used for efficient storing and lookup of the reverse\n     * index of token to document ref.\n     *\n     * @constructor\n     */\n    lunr.TokenStore = function() {\n        this.root = { docs: {} }\n        this.length = 0\n    }\n\n    /**\n     * Loads a previously serialised token store\n     *\n     * @param {Object} serialisedData The serialised token store to load.\n     * @returns {lunr.TokenStore}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.load = function(serialisedData) {\n        var store = new this\n\n        store.root = serialisedData.root\n        store.length = serialisedData.length\n\n        return store\n    }\n\n    /**\n     * Adds a new token doc pair to the store.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to store the doc under\n     * @param {Object} doc The doc to store against the token\n     * @param {Object} root An optional node at which to start looking for the\n     * correct place to enter the doc, by default the root of this lunr.TokenStore\n     * is used.\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.add = function(token, doc, root) {\n        var root = root || this.root,\n            key = token.charAt(0),\n            rest = token.slice(1)\n\n        if (!(key in root)) root[key] = { docs: {} }\n\n        if (rest.length === 0) {\n            root[key].docs[doc.ref] = doc\n            this.length += 1\n            return\n        } else {\n            return this.add(rest, doc, root[key])\n        }\n    }\n\n    /**\n     * Checks whether this key is contained within this lunr.TokenStore.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to check for\n     * @param {Object} root An optional node at which to start\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.has = function(token) {\n        if (!token) return false\n\n        var node = this.root\n\n        for (var i = 0; i < token.length; i++) {\n            if (!node[token.charAt(i)]) return false\n\n            node = node[token.charAt(i)]\n        }\n\n        return true\n    }\n\n    /**\n     * Retrieve a node from the token store for a given token.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to get the node for.\n     * @param {Object} root An optional node at which to start.\n     * @returns {Object}\n     * @see TokenStore.prototype.get\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.getNode = function(token) {\n        if (!token) return {}\n\n        var node = this.root\n\n        for (var i = 0; i < token.length; i++) {\n            if (!node[token.charAt(i)]) return {}\n\n            node = node[token.charAt(i)]\n        }\n\n        return node\n    }\n\n    /**\n     * Retrieve the documents for a node for the given token.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to get the documents for.\n     * @param {Object} root An optional node at which to start.\n     * @returns {Object}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.get = function(token, root) {\n        return this.getNode(token, root).docs || {}\n    }\n\n    lunr.TokenStore.prototype.count = function(token, root) {\n        return Object.keys(this.get(token, root)).length\n    }\n\n    /**\n     * Remove the document identified by ref from the token in the store.\n     *\n     * By default this function starts at the root of the current store, however\n     * it can start at any node of any token store if required.\n     *\n     * @param {String} token The token to get the documents for.\n     * @param {String} ref The ref of the document to remove from this token.\n     * @param {Object} root An optional node at which to start.\n     * @returns {Object}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.remove = function(token, ref) {\n        if (!token) return\n        var node = this.root\n\n        for (var i = 0; i < token.length; i++) {\n            if (!(token.charAt(i) in node)) return\n            node = node[token.charAt(i)]\n        }\n\n        delete node.docs[ref]\n    }\n\n    /**\n     * Find all the possible suffixes of the passed token using tokens\n     * currently in the store.\n     *\n     * @param {String} token The token to expand.\n     * @returns {Array}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.expand = function(token, memo) {\n        var root = this.getNode(token),\n            docs = root.docs || {},\n            memo = memo || []\n\n        if (Object.keys(docs).length) memo.push(token)\n\n        Object.keys(root)\n            .forEach(function(key) {\n                if (key === 'docs') return\n\n                memo.concat(this.expand(token + key, memo))\n            }, this)\n\n        return memo\n    }\n\n    /**\n     * Returns a representation of the token store ready for serialisation.\n     *\n     * @returns {Object}\n     * @memberOf TokenStore\n     */\n    lunr.TokenStore.prototype.toJSON = function() {\n        return {\n            root: this.root,\n            length: this.length\n        }\n    };\n    return lunr;\n})();\n","var isMac = navigator.userAgent.indexOf('Mac OS X') != -1 ? true : false;","console.log(\"%cHey there, fellow developer. Find me on GitHub at https://github.com/rdwatters - Cheers.\", \"font-size: 20px; color: #01589B; font-family:'proximanova';\");","//es2015 extra string methods *not* transpiled with Babel\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(searchString, position) {\n    position = position || 0;\n    return this.indexOf(searchString, position) === position;\n  };\n}\nif (!String.prototype.includes) {\n  String.prototype.includes = function() {'use strict';\n    return String.prototype.indexOf.apply(this, arguments) !== -1;\n  };\n}\nif (!String.prototype.endsWith) {\n  String.prototype.endsWith = function(searchString, position) {\n      var subjectString = this.toString();\n      if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n        position = subjectString.length;\n      }\n      position -= searchString.length;\n      var lastIndex = subjectString.indexOf(searchString, position);\n      return lastIndex !== -1 && lastIndex === position;\n  };\n}\n//http://purl.eligrey.com/github/classList.js/blob/master/classList.js\n\nif (\"document\" in self && !(\"classList\" in document.createElement(\"_\"))) {\n    (function(j) {\n        \"use strict\";\n        if (!(\"Element\" in j)) {\n            return\n        }\n        var a = \"classList\",\n            f = \"prototype\",\n            m = j.Element[f],\n            b = Object,\n            k = String[f].trim || function() {\n                return this.replace(/^\\s+|\\s+$/g, \"\")\n            }, c = Array[f].indexOf || function(q) {\n                var p = 0,\n                    o = this.length;\n                for (; p < o; p++) {\n                    if (p in this && this[p] === q) {\n                        return p\n                    }\n                }\n                return -1\n            }, n = function(o, p) {\n                this.name = o;\n                this.code = DOMException[o];\n                this.message = p\n            }, g = function(p, o) {\n                if (o === \"\") {\n                    throw new n(\"SYNTAX_ERR\", \"An invalid or illegal string was specified\")\n                }\n                if (/\\s/.test(o)) {\n                    throw new n(\"INVALID_CHARACTER_ERR\", \"String contains an invalid character\")\n                }\n                return c.call(p, o)\n            }, d = function(s) {\n                var r = k.call(s.getAttribute(\"class\") || \"\"),\n                    q = r ? r.split(/\\s+/) : [],\n                    p = 0,\n                    o = q.length;\n                for (; p < o; p++) {\n                    this.push(q[p])\n                }\n                this._updateClassName = function() {\n                    s.setAttribute(\"class\", this.toString())\n                }\n            }, e = d[f] = [],\n            i = function() {\n                return new d(this)\n            };\n        n[f] = Error[f];\n        e.item = function(o) {\n            return this[o] || null\n        };\n        e.contains = function(o) {\n            o += \"\";\n            return g(this, o) !== -1\n        };\n        e.add = function() {\n            var s = arguments,\n                r = 0,\n                p = s.length,\n                q, o = false;\n            do {\n                q = s[r] + \"\";\n                if (g(this, q) === -1) {\n                    this.push(q);\n                    o = true\n                }\n            } while (++r < p);\n            if (o) {\n                this._updateClassName()\n            }\n        };\n        e.remove = function() {\n            var t = arguments,\n                s = 0,\n                p = t.length,\n                r, o = false;\n            do {\n                r = t[s] + \"\";\n                var q = g(this, r);\n                if (q !== -1) {\n                    this.splice(q, 1);\n                    o = true\n                }\n            } while (++s < p);\n            if (o) {\n                this._updateClassName()\n            }\n        };\n        e.toggle = function(p, q) {\n            p += \"\";\n            var o = this.contains(p),\n                r = o ? q !== true && \"remove\" : q !== false && \"add\";\n            if (r) {\n                this[r](p)\n            }\n            return !o\n        };\n        e.toString = function() {\n            return this.join(\" \")\n        };\n        if (b.defineProperty) {\n            var l = {\n                get: i,\n                enumerable: true,\n                configurable: true\n            };\n            try {\n                b.defineProperty(m, a, l)\n            } catch (h) {\n                if (h.number === -2146823252) {\n                    l.enumerable = false;\n                    b.defineProperty(m, a, l)\n                }\n            }\n        } else {\n            if (b[f].__defineGetter__) {\n                m.__defineGetter__(a, i)\n            }\n        }\n    }(self))\n};"],"sourceRoot":"/source/"}